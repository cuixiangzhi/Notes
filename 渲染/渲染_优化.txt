前言
    优化是一点点积累的
基础知识
    Gfx.SetPass
        一个DrawCall分为setpass和batch两部分,相同的setpass也就是使用相同的材质,batch是合并的Mesh个数
        setpass是在CPU内处理的,需要做很多拷贝、校验,占用了大部分渲染时间
    Gfx.WaitForTargetFPS
        CPU速度很快,超出了目标帧率,例如限帧30帧,上一帧耗时15ms,那么当前帧WaitForTargetFPS=33-15=18ms
    Gfx.WaitForPresent
        CPU等待GPU渲染完成或者VSync信号到来,GPU负载很高
高中低配选项控制
    项目资源规范
        界面
            字体一个
            公共图集 2048*2048*(3~4)
            功能图集 1024*512|512*512*(20~40)
            特殊功能 2048*1024|1024*1024*(3~5)
            特殊背景 
        角色
        场景
        特效
        音频
    机型分类规则

    可调节选项
        1.LODGroup
            使用LODGroup组件设置Render列表,根据网格占屏比选择适当的LODMESH,支持淡入淡出(unity_LODFade)
            物体占屏比是通过当前屏幕空间AABB和近平面时物体的AABB的比例值来计算
        2.ShaderLOD
            shader实现多个不同LOD的subshader,LOD越低效果越差但是性能越好,例如PBS有高中低三个版本
            shader.globalMaximumLODLevel设置当前渲染质量,低于该值的shader的pass才会被使用
            shader.maximumLodLevel设置特定shader的渲染质量
        3.QualityLevel
            运行时通过修改Unity的渲染配置,来提高质量或者降低消耗,通过QualitySettings.SetQualityLevel调节
            渲染
                PixelLightCount Important模式一定是逐像素的,Important个数小于指定个数会选取Auto模式的作为逐像素光源
                TextureQuality  降低显存占用(0级MipMap,贴图R/W一定要关闭),FullRes是完整分辨率,HalfRes是一半分辨率
                AnisoTropicTex  各向异性纹理采样是否开启,开启之后远处的细节会变清晰,PerTexture会使用贴图的设置,ForceOn会强制设置所有贴图
                AntiAliasing    MSAA抗锯齿的采样点个数,可以是2x、4x、8x,需要配合Camera的MSAA选项使用
                SoftParticles   开启之后粒子会计算深度差dz来柔化边缘(当粒子距离物体特别近的时候穿插不会出现硬边),计算需要深度图
                Resolution      通过ScreenAPI设置渲染目标分辨率或者自定义RT作为渲染目标或者使用Camera的动态分辨率选项
            阴影
                Shadows          软阴影会多一步模糊操作,可以减弱锯齿
                ShadowDistance   距离摄像机的深度值低于该值时使用实时阴影,同时该值会影响划分阴影层级的范围
                ShadowNearOffset 直接使用8个顶点计算时可能会导致更外面的物体没有产生阴影(比如高大的建筑物在视椎体外面)
                ShadowCascades   把观察体划分为N个等级,每个等级根据8个顶点和平行光方向计算正交摄像机的AABB,提高近处物体的阴影深度的精度
            其它
                VSyncCount       关闭后Unity会全速跑Update,否则会根据同步方式sleep一段时间在执行Update,高帧率可以减少消耗
        4.GraphicsTier
            阴影
                CascadedShadows  级联阴影,根据摄像机观察范围划分N个等级分别使用不同的深度图,提高近处物体的精度
            HDR
                UseHDR&HDRMode   HDR模式总开关,HDR模式摄像机渲染帧缓冲的格式,FP16是64位,R11G11B10是32位不带A通道
                                 开启后会额外创建一个缓冲区存储HDR计算结果
        5.PostProcess
            后期
            Bloom
内存方面的优化
    shaderlab
        shader_feature
            定义的变体没有使用到不会被编译
            使用#pragma shader_feature 来定义
            使用[Toggle(feature) ..]在材质上显示该选项
        multi_compile
            定义的变体都会编译
            使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
            keyword最多256个,超过这个值会报错
        variants
            宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载时间并增加内存占用
        判断是否被使用:
            shader如果单独打包,此时shader不会编译生成任何变体
            shader和材质打包,shader会根据材质的keyword信息编译生成对应的变体
            实现IPreprocessShaders接口打包时剔除变体
        强制生成变体:
            1.把shader放在always include shaders
            2.把shader放在resources内
            3.增加多余的材质,定义对应的变体keyword
            4.5.0以后版本提供的shader_variant_collection,针对每个shader指定要使用哪些keyword,把collection放在preload或者和shader打包在一起
    r/w_memory
        read/write enabled
            开启该选项的纹理、网格会在内存中存在两份(显存+内存)
        dynamic_batching
            开启之后300顶点以下的网格会强制开启R/W
    mesh_memory
        MeshCompression
            使用压缩算法减少硬盘空间占用,默认关闭
        OptimizeMeshData
            打bundle时剔除shader没有使用到的顶点属性,可以减小包体
        VertexCompression
            降低顶点属性的精度,针对300顶点以上、未开启R/W的网格生效
    component_memory
        Animator
            FBX导入时Rig不要生成Avatar(除非需要动作混合)
        Rigidbody

渲染方面的优化
    postprocess
        合并多个后处理效果
            1.使用Unity提供的PostProcessing，关闭不使用的效果
            2.使用统一的脚本管理自定义的一些效果,例如淡入淡出、屏幕水波、景深等等
    commandbuffer
        自定义颜色和深度缓冲区
            为了使用HDR,颜色图需要使用Float格式,RGB111110Float 
            为了兼容机型,深度图格式用Depth、RHalf、RFloat
            Camera.SetTargetBuffers(RenderBuffer color,RenderBuffer depth)
            有时候需要用深度图来做额外处理,而UNITY需要多渲染一次场景生成深度图
        自定义渲染命令
            CommandBuffer.Blit()->Camera.AddCommandBuffer()
            后期特效可以利用Blend命令减少内存的拷贝操作

