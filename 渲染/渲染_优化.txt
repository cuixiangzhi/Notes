前言
    优化是一点点积累的
高中低配选项控制
    项目资源规范
        
    机型分类规则

    可调节选项
        1.ShaderLOD
            shader实现多个不同LOD的subshader,LOD越低效果越差但是性能越好,例如PBS有高中低三个版本
        2.
内存方面的优化
    variants
            shader_feature
                定义的变体没有使用到不会被编译
                使用#pragma shader_feature 来定义
                使用[Toggle(feature) ..]在材质上显示该选项
            multi_compile
                定义的变体都会编译
                使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
                keyword最多256个,超过这个值会报错
            variants
                宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载时间并增加内存占用
            判断是否被使用:
                shader如果单独打包,此时shader不会编译生成任何变体
                shader和材质打包,shader会根据材质的keyword信息编译生成对应的变体
            强制生成变体:
                1.把shader放在always include shaders
                2.把shader放在resources内
                3.增加多余的材质,定义对应的变体keyword
                4.5.0以后版本提供的shader_variant_collection,针对每个shader指定要使用哪些keyword
                把collection放在preload或者和shader打包在一起
    mesh
        PlayerSettings
            DynamicBatching     300顶点以下的MESH无论是否开启R/W,内存都会翻倍
            OptimizeMeshData    用来在打bundle时剔除shader没有使用到的顶点属性,可以减小包体
            VertexCompression   降低顶点属性的精度
                                该选项是否生效包含以下几种条件
                                    1.是否开启了DynamicBatching,开启后300顶点以下的MESH不会执行顶点压缩
                                    2.是否开启了R/W,开启后不会执行顶点压缩
                                    3.是否开启了MeshCompression,开启后会覆盖掉顶点压缩配置
        ModelImporter
            Read/Write Enabled  开启会在多一份内存
            MeshCompression     使用压缩算法减少硬盘空间占用,默认关闭
渲染方面的优化
    lod
        层次细节,根据物体所处的位置显示不同精度的模型或者使用不同的渲染策略
        MESH_LOAD
            使用方式:
                添加LODGroup组件,增加LOD,摄像机图标拖拽可以查看具体LOD效果
                每个LOD设置Renderer列表
                每个LOD左侧标识的百分比代表物体在屏幕空间占屏比低于该值时使用这个LOD的策略
                物体占屏比是通过当前屏幕空间AABB和近平面时物体的AABB的比例值来计算
                LOD支持淡入淡出,通过uniform变量unity_LODFade.x来获取blendfactor,LOD_FADE_PERCENTAGE|LOD_FADE_CROSSFADE
            全局配置
                Unity->Edit->QualitySetting
                MaximumLODLevel控制使用的最大LOD级别,超过这个值不会被编译
                LODBias控制在两个LOD之间的如何使用,0到1越接近1越靠前
        SHADER_LOD
            使用方式:
                给每个shader的pass增加 LOD 限定值
                通过shader.globalMaximumLODLevel设置当前渲染质量,低于该值的shader的pass才会被使用
                通过shader.maximumLodLevel设置特定shader的渲染质量
        CULL
            自己实现四叉树或者八叉树动态分块加载,执行遮挡剔除
    postprocess
        合并多个后处理效果
            1.使用Unity提供的PostProcessing，关闭不使用的效果
            2.使用统一的脚本管理自定义的一些效果,例如淡入淡出、屏幕水波、景深等等
    custombuffer
        自定义颜色和深度缓冲区
            为了使用HDR,颜色图需要使用Float格式,RGB111110Float 
            为了兼容机型,深度图格式用Depth、RHalf、RFloat
            Camera.SetTargetBuffers(RenderBuffer color,RenderBuffer depth)
            有时候需要用深度图来做额外处理,而UNITY需要多渲染一次场景生成深度图
        自定义渲染命令
            CommandBuffer.Blit()->Camera.AddCommandBuffer()
            AfterForwardOpaque深度图就不会再更新了,因为只有不透明物体才会更新深度图
    setpass
        一个DC分为setpass和draw两部分,相同的setpass也就是使用相同的材质,batch是MESH个数
        setpass是在CPU内处理的,需要做很多拷贝、校验,占用了大部分渲染时间
代码方面的优化
    数组[]
        1.自定义一个全局的数组管理类,创建List数组代替[]数组,减少临时数组的分配和数量
        2.不要使用GetComponents返回[],传递一个List数组来获取,减少GC