基础
    降采样
        对一幅M*N的图像进行s倍的降采样,得到一张(M>>s)*(N>>s)的图像,原图中s*s个像素合并为一个像素
    深度差
        根据屏幕深度的差和阈值来判断是否距离很近,在Soft粒子上有应用
        ComputeScreenPos计算齐次视口坐标->tex2DProj+LinearEyeDepth获取不透明物体深度->ObjectToView计算透明物体深度
    颜色差
        根据相邻像素颜色的差异突变判断图像边缘
    亮度差
        根据相邻像素亮度的差异突变判断图像边缘
    屏幕深度->世界坐标
        1.利用UV坐标和深度图重建世界坐标(首先从01映射到-11,然后利用摄像机投影逆矩阵变换再利用世界2摄像机的逆矩阵得出结果)
        2.根据相似三角形和插值得出目标点的射线向量再乘以深度值,再算上摄像机位置可得出世界坐标
    高斯模糊
        原理:利用高斯分布公式对周围像素点做加权平均 G(x,y)=(1/2πσ²)exp(-(x²+y²)/2σ²),方差σ可以取1
        顶点shader
            计算高斯核UV坐标,在顶点内计算之后三角面的其它像素UV插值生成
        像素shader
            根据高斯核采样像素点加权平均,得出最终结果
    ZPrePass
        剔除AlphaTest物体,把AlphaTest的物体用ColorMask提前写深度,然后正常渲染的时候改成ZEqual
场景渲染
    地形
    植被
    水面
    天气
    昼夜
    天光
角色渲染
    头发
    眉毛
    眼睛
    脸部
    皮肤
    衣服
后期特效
    景深效果
        原理:利用深度差确定模糊范围,也就是模糊的焦距
        实现:简单的一个后期处理,根据模糊距离进行高斯模糊操作即可
    运动模糊
        原理:摄像机原理(拍摄100帧,每4帧叠加,最终为25帧),对连续的几帧图像进行累加
        实现:
            游戏不可能实时渲染N倍的帧,效果可能不够真实
            可以利用一张RT存储上一帧的结果和当前帧做混合
            或者利用世界坐标的移动距离进行模糊
        顶点shader
            普通vertex变换
        像素shader
            两张纹理混合 
                Blend SrcAlpha OneMinusSrcAlpha
            根据NDC坐标计算像素点移动向量
                读取深度d = tex2D(_CameraDepthTexture,i.uv)
                根据深度和uv得出ndc坐标 ndc = float4(2*uvx-1,2*uvy-1,2d-1,1)
                根据NDC和投影矩阵计算世界坐标 world = mul(_ndc2World,ndc)
                根据世界坐标和上一帧的投影矩阵计算上一帧的NDC坐标 lastndc = mul(_lastWorld2NDC,world)
                根据两个NDC计算移动向量 vec = ndc - lastndc
                根据移动向量计算偏移UV坐标加权平均 c+=uv+vec*_BlurSize c/=n
    辉光效果
        原理:先利用亮度提取出超过指定阈值的部分,然后对其做高斯模糊处理,最后叠加到原图上
        需要4张RT,SRC->TMP0提取高亮部分,TMO0->TMP1->TMP0水平和垂直模糊,,SRC->DST用TMP0叠加得出最终结果
        顶点shader
            普通vertex变换
        像素shader
            提取计算 亮度阈值 col *= clamp(luminance(c) - _LuminanceThreshold,0,1)
            模糊计算 加权平均,高斯模糊
            叠加计算 直接相加 tex2D(SRC) + tex2D(TMP0)
    后期校色
        原理:RGB颜色模型与HSV颜色模型转换,YUV亮度计算,对比度插值
        顶点shader:
            普通的vertex变换和uv赋值
        像素shader:
            texColor = tex2D(i.uv,_MainTex)
            亮度修改,直接乘以亮度系数即可  
                finalColor = texColor * _Brightness
            饱和度修改,先计算出相同亮度(YUV颜色模型)下饱和度为0的灰色,然后根据饱和度和finalColor做插值
                luminance = dot(texColor.rgb,fixed3(0.2125,0.7154,0.0721)或者fixed3(0.299,0.587,0.114))
                luminanceColor = fixed3(luminance,luminance,luminance)
                finalColor = lerp(luminanceColor,finalColor,_Saturation)
            对比度修改,灰度区间从[A,B]变换到[C,D]
                contrastColor = fixed3(0.5,0.5,0.5)
                finalColor = lerp(contrastColor,finalColor,_Contrast)
            ToneMap
                原理:ACES公式 saturate([x*(a*x+b)]/[x*(c*x+d)+e]) a=2.51 b=0.03 c=2.43 d=0.59 e=0.14
特殊表现
    屏幕波纹
        原理:UV动画,屏幕每个像素的UV坐标以中心点为圆心,向圆外偏移,根据距离中心点的距离和偏移的时间计算偏移程度
        顶点shader: 
            普通的vertex变换和uv赋值
        像素shader:
            首先计算出圆心指向当前UV的向量(x方向乘以宽高比,确保波纹是圆形的) 
                dv = (i.uv - fixed2(0.5,0.5)) * (_ScreenParams.x/_ScreenParams.y,1)
            然后计算波纹震动程度
                factor = a*sin(w)  
                a是振幅,从中心到边缘逐渐减弱,a=lerp(ARG_A,0,curOffset/maxOffset) ARG_A=0.1
                w是相位,w=频率*(passedTime+offset*3)
            接着计算波纹波动范围
                波动的中心 center = moveSpeed*passedTime
                波动的范围 range
                波动的偏移 offsetFactor = clamp(range-abs(center-offset),0,1) / range,避免波动范围内的明显的边界
                波动的比例 factor = factor * offsetFactor
            最后计算扩散后的UV坐标 uv = uv + dv * factor