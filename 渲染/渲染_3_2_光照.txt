光照方程
    经验模型
        Phong
            I = 环境光 + 漫反射光 + 高光
            I = KaIa + KdId*dot(n,l) + KsIs*pow(max(0,dot(r,v)),α)
            K是反射系数,I是光照强度,n是法线方向,l是入射方向,v是视线方向,r是反射方向 α是表面粗糙度,α越小越粗糙
        BlinnPhone
            Phone模型在反射方向和观察方向夹角超过90度,也就是观察方向趋向平行表面时,Phong会发生突变,BlinnPhong更接近真实情况
            pow(dot(n,h),α),h是l和v的半角向量,v在趋向于平行表面过程中h与n的夹角始终在90度之内,也就是边缘有一个渐变过程
    物理模型
        公式原理以及输入参数
            http://artisaverb.info/PBT.html 资源库
            https://www.cnblogs.com/timlly/p/10631718.html 原理介绍
            https://blog.csdn.net/i_dovelemon/article/details/79091105 IBL算法
            终极公式
                反射方程
                    Lo(p,wo) = ∫(fd+fs)Li(p,wi)dot(n,wi)dwi
                    fr(l,v)分为diffuse和specular两部分,采用不同的公式
                球谐光照
                    球谐基函数需要无限的分量才可以完整重建原始信号,有限的分量只保留了低频信号,因此只能模拟漫反射
                    某个点的入射光来自以该点为球心的球,入射光只考虑方向,球体半径可以设为1
                    对该点的入射光进行蒙特卡洛积分和球谐基函数投影,得出球谐基函数各个分量的系数
                    系数计算公式(单位球体均匀采样的概率密度函数为P=1/S=1/4π)
                        Ci=1/NP*∑L*Yi   L'=∑Ci*Yi(对所有球谐基分量求和可以得出原光照函数的近似值)
                        Ci表示球谐基系数 N表示采样点个数 P是概率密度函数 L是入射光函数 Yi是球谐基函数 L'是重建后的光照函数
                    球谐基函数公式
                        l表示阶数,l越高信号频率越高,m表示每一阶内的某个基底函数,每个基底函数都是正交的,n阶球谐函数有n*n个基底函数
                        具体公式计算公式参考杂项球谐公式图片(根据采样点的0,φ计算该点对应的球谐函数Yi) l,m转换为连续序列i=l(l+1)+m
                    球谐函数应用
                        预计算得出球谐基函数系数Ci,运行时可以重建原光照函数,光照探针记录了所在位置的入射光的球谐基函数系数
                IBL漫反射
                    1.用环境贴图HDRCubeMap作为环境光源计算Li,针对半球采样加和计算Lo,生成LightMap
                        积分简化为黎曼和形式
                            Lo ≈ fd*(2π/N1)*(π/2/N2)∑Licos0sin0 = (kd*c*π)/(N1*N2)*∑(0-N1)∑(0-N2)Licos0sin0
                        计算注意事项
                            在切线空间下球坐标(0,φ)转换为笛卡尔坐标pt=(x,y,z)
                            切线空间转世界空间pw=T*pt.x+B*pt.y+N*pt.z
                    2.运行时采样LightMap或者根据球谐函数计算漫反射光照
                IBL镜面反射
                    1.计算环境反射贴图HDRCubeMap,可以设置多个,生成到ReflectionProbe中存储
                    2.根据观察方向和法线计算反射方向,根据反射方向采样CudeMap
                    3.根据采样结果和反射方程计算反射颜色,预计算需要表面粗糙度来计算DG,F项运行时计算
        具体实现
            光照分解
                直接光 Diffuse Specular
                间接光 IndirectDiffuse(动态物体来源于LightProbes,静态物体来源于LightMap)
                       InDirectSpecular(全都来源于ReflectionProbes)
                最终结果 直接光*Shadow+间接光*AO
            灯光颜色
                精准光源只会在一个方向对辐照度有贡献,其他方向都是0,灯光颜色和强度用来表示入射辐射率Li
                直接光
                    实时计算,由于强度、距离、阴影、环境遮挡的影响会发生衰减
                    directlight.color *= shadow*atten*ao
                间接光
                    静态物体通过LightMap直接读取,动态物体通过SH函数计算
                    indirect.diffuse = (sh|lightmap) * ao
                    indirect.specular = envirmap * ao
            反射比例
                ks=lerp(vec3(0.04),albedo.rgb,metallic)
                kd=lerp(vec(0.96),(1-albedo.rgb),metallic)
            漫反射BRDF
                diffTerm = albedo/π
                diffTerm = albedo/π * (1+(Fd-1)(1-dot(n,l))⁵*(1+(Fd-1)(1-dot(n,v))⁵)) Fd=0.5+2m(n,l)²
            镜面反射BRDF
                D=k/π*[dot(n,h)²*(k-1)+1]²                          k=rough²
                F=F0+(1-F0)(1-dot(l,h))⁵                            F0=ks
                G=Gs(n,v,k)*Gs(n,l,k) Gs=nv/[nv(1-k)+k]             k=(rough+1)²/8
                specTerm = DFG / 4*nl*nv
            终极结果
                直接光 diff = diffTerm * light.color * dot(n,l) * kd
                直接光 spec = specTerm * light.color * dot(n,l)
                间接光 diff = indirect.diffuse * kd
                间接光 spec = indirect.specular * F
光照探头
    LightProbe
        给动态物体提供间接漫射光,避免实时补光的方式来提高角色的亮度
        添加间接光的采样点(LightProbe),记录场景的间接光信息
        采样点把整个空间分割为一个个四面体,物体在一个四面体内根据权重获取不同采样点的影响程度
        采样点尽量布置在光照变化较大的地方(进入阴影的地方)
        LightmapSettings.lightProbes.bakedProbes可以获取烘焙后的信息
    ReflectionProbe
        给所有物体提供间接反射光,动态的间接高光
光照模式
    Realtime
        直接光实时计算,阴影使用ShadowMap计算(ShadowMap只计算ShadowDistance以内的动态对象)
        RealtimeGI计算静态物体表面所有可能的反射光线,运行时动态计算间接光
        IndirectMultiplier在强度不是0并且不开启RealtimeGI时会把间接光烘焙到LightMap
    Mixed
        BakeIndirect
            直接光实时计算,间接光存储在LightMap和LightProbes,阴影使用ShadowMap计算
        ShadowMask
            直接光实时计算,间接光存储在LightMap和LightProbes,阴影使用ShadowMask(最多4个Mixed光源,存储直接光被静态物体遮挡信息)
                            动态物体Receive     静态物体Receive
            动态物体Cast    ShadowMap           ShadowMap+ShadowMask
            静态物体Cast    LightProbes         ShadowMap+ShadowMask
    Baked
        直接光、间接光、阴影烘焙到LightMap和LightProbes,只对静态物体生效,LightProbes对动态物体生效
渲染路径
    Forward
        MESH->VS->FS(光照计算)->FRAME_BUFFER
        ForwardBase: 
            #pragma multi_compile_fwdbase
            计算自发光、环境光、主平行光、SH光、光照贴图、阴影
            Unity中设置为NotImporant的光会被按照逐顶点或者SH处理
            逐顶点光照计算 Shade4PointLights(...) unity_4LightPosXYZColorAtten
            球谐光照计算 
        ForwardAdd:  
            Blend One One 
            #pragma multi_compile_fwdadd
            计算额外的逐像素光源,AddPass会根据照亮该物体的光源数量被执行多次
            照亮每个物体的逐像素光源个数有限制,Unity会根据光源的类型及对物体的影响程度(距离、强度、类型等)进行排序
            _LightColor0和_WorldSpaceLightPos0存储当前逐像素光源的颜色和位置
        光源信息
            Unity会根据当前光源类型为PASS的执行设置对应的光源属性 位置、颜色、衰减纹理、变换矩阵
            获取光的方向 
                UnityWorldSpaceLightDir(i.worldPos)
            获取光的颜色 
                _LightColor0
            获取光的衰减 
                平行光为 atten=1
                其它类型 
                        lightSpacePos=mul(_LightMatrix0,i.worldPos).xyz 
                        attenUV=dot(lightSpacePos,lightSpacePos).xx
                        atten=tex2D(_LightTexture0,attenUV).UNITY_ATTEN_CHANNEL;
                直接获取 
                        UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos)
    Deferred
        第一次渲染
            不计算光照信息,只进行深度测试,光照相关数据写入G-BUFFER(坐标、法线、UV、反射系数等等)
        第二次渲染
            遍历屏幕像素,针对有效的像素点读取G-BUFFER数据进行光照计算,更新颜色缓冲区
            Unity默认使用Standard光照模型来计算,Internal-DeferrredShading.shader
        计算流程
            MESH->VS->FS(无光)->MRT(深度、法线、颜色三个BUFFER存储光照所需信息)->FRAME_BUFFER
        GBuffer信息
            RT0,存储漫反射颜色,A通道未使用
            RT1,存储高光反射颜色,A通道存储高光指数
            RT2,存储法线方向,A通道未使用
            RT3,存储自发光+光照贴图+反射探针
    ShadowCaster
        渲染阴影映射纹理时调用该shader,没有会调用Fallback的对应shader,否则不产生阴影