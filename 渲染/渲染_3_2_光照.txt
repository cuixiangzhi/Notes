光照方程
    经验模型
        Phong
            I = 环境光 + 漫反射光 + 高光
            I = KaIa + KdId*dot(n,l) + KsIs*pow(max(0,dot(r,v)),α)
            K是反射系数,I是光照强度,n是法线方向,l是入射方向,v是视线方向,r是反射方向 α是表面粗糙度,α越小越粗糙
        BlinnPhone
            Phone模型在反射方向和观察方向夹角超过90度,也就是观察方向趋向平行表面时,Phong会发生突变,BlinnPhong更接近真实情况
            pow(dot(n,h),α),h是l和v的半角向量,v在趋向于平行表面过程中h与n的夹角始终在90度之内,也就是边缘有一个渐变过程
    物理模型
	    BRDF:
            https://zhuanlan.zhihu.com/p/21376124
            https://chengkehan.github.io/PunctualLightSource.html
            https://www.cnblogs.com/luxishi/p/6409716.html
            http://www.voidcn.com/article/p-uamrlclq-brb.html
        	通用公式
        		Lo(r)=∫*f(l,v)*Li(l)*dot(n,l)*dwi
            f(l,v)分为diffuse和specular两部分,采用不同的公式
                LambertDiffuse
                    fd=albedo/π * dot(n,l)
                DisneyDiffuse 
                    fd=albedo/π * (1+(Fd-1)(1-dot(n,l))⁵*(1+(Fd-1)(1-dot(n,v))⁵)) Fd=0.5+2m(n,l)²
                CookTorranceBRDF
                    fs=DFG/[4*dot(n,l)*dot(n,v)]
                    D是法线分布函数 F是菲涅尔反射量 G是遮挡比例函数
                    UnrealEngine4中使用的DFG函数分别是
                        Trowbridge-Reitz GGX  D=m²/π*[dot(n,h)²*(m²-1)+1]² m是粗糙度 h是半角向量                    
                        Fresnel-Schlick       F=F0+(1-F0)(1-dot(n,v))⁵ 非金属F0值一般在0.17以下,金属一般在0.5-1.0之间
                        Smith's Schlick-GGX   Gs=dot(n,v)/[dot(n,v)(1-k)+k] G=Gs(n,v,k)Gs(n,l,k) m是粗糙度 k=(m+1)²/8
                    Unity使用的DFG函数与UnrealEngine一致
            理论计算
                FinalColor = 直接光(diffuse+specular)*shadow+间接光(diffuse+specular)*AO
            最终结果
                diffColor * (GI.diffuse + diffBRDF * GI.light.color) + specBRDF * GI.light.color + surfaceReduction * GI.specular * Fresnel
            反射率计算
                现实中的物体都存在或多或少的漫反射和高光反射,非金属高光反射率一般是Crgb=0.04              
                根据能量守恒(金属度强弱会影响比例分配)
                    高光反射率   
                        specColor=lerp(Crgb,albedo,metallic)
                    漫反射率   
                        oneMinusReflectivity = 0.96 - metallic * 0.96
                        diffColor=albedo*oneMinusReflectivity; 
                    间接高光衰减
                        surfaceReduction = 1/(m^2+1) 表面越粗糙,间接高光越弱
            阴影计算
                GI.light.color是经过了阴影和衰减计算后的颜色
            固有色贴图
                一定没有光照和阴影的颜色信息,金属HSB亮度范围是72.9-100,非金属HSB亮度范围是19.6–95.2
                颜色看起来很平,没有亮度渐变,可以支持多张Albedo混合
            金属度贴图
                一定是接近黑白图的,一个金属材质的金属度一定是接近1的,非金属一定是接近0的,加了金属度背光面会发黑
            粗糙度贴图
                可以任意设置,主要表现划痕、磨损等细节
            法线贴图
                一定是偏蓝色的,存储了切线空间的法线信息
            AO贴图
                半球积分、遮挡关系、天空光
光照模式
    Realtime
        直接光实时计算,阴影使用ShadowMap计算(ShadowMap只计算ShadowDistance以内的动态对象)
        RealtimeGI计算静态物体表面所有可能的反射光线,运行时动态计算间接光
        IndirectMultiplier在强度不是0并且不开启RealtimeGI时会把间接光烘焙到LightMap
    Mixed
        BakeIndirect
            直接光实时计算,间接光存储在LightMap和LightProbes,阴影使用ShadowMap计算
        ShadowMask
            直接光实时计算,间接光存储在LightMap和LightProbes,阴影使用ShadowMask(最多4个Mixed光源,存储直接光被静态物体遮挡信息)
                            动态物体Receive     静态物体Receive
            动态物体Cast    ShadowMap           ShadowMap+ShadowMask
            静态物体Cast    LightProbes         ShadowMask
        Subtractive
            直接光、间接光、阴影烘焙到LightMap和LightProbes
                            动态物体Receive     静态物体Receive
            动态物体Cast    ShadowMap           主光ShadowMap+DistanceLightMap
            静态物体Cast    LightProbes         ShadowMask
    Baked
        直接光、间接光、阴影烘焙到LightMap和LightProbes,只对静态物体生效,LightProbes对动态物体生效
渲染路径
	Vertex
		支持8个点光源,按照亮度排序,位置颜色信息存储在指定数组内
		MESH->VS(光照计算)->FS->FRAME_BUFFER
	Forward
		根据配置的逐像素光源个数,提取最亮的几个光源计算光照,其余的光源都以球谐函数
		MESH->VS->FS(光照计算)->FRAME_BUFFER
		ForwardBase: 
			#pragma multi_compile_fwdbase
			计算自发光、环境光、主平行光、逐顶点光、SH光、光照贴图、阴影
			Unity中设置为NotImporant的光会被按照逐顶点或者SH处理
			逐顶点光照计算 Shade4PointLights(...) unity_4LightPosXYZColorAtten
			球谐光照计算 
		ForwardAdd:  
			Blend One One 
			#pragma multi_compile_fwdadd
			计算额外的逐像素光源,AddPASS会根据照亮该物体的光源数量被执行多次
			照亮每个物体的逐像素光源个数有限制,Unity会根据光源的类型及对物体的影响程度(距离、强度、类型等)进行排序
			_LightColor0和_WorldSpaceLightPos0存储当前逐像素光源的颜色和位置
		光源信息
			Unity会根据当前光源类型为PASS的执行设置对应的光源属性 位置、颜色、衰减纹理、变换矩阵
			获取光的方向 
				UnityWorldSpaceLightDir(i.worldPos)
			获取光的颜色 
				_LightColor0
			获取光的衰减 
				平行光为 atten=1
				其它类型 
						lightSpacePos=mul(_LightMatrix0,i.worldPos).xyz	
						attenUV=dot(lightSpacePos,lightSpacePos).xx
						atten=tex2D(_LightTexture0,attenUV).UNITY_ATTEN_CHANNEL;
				直接获取 
						UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos)
	Deferred
		第一次渲染
			不计算光照信息,只进行深度测试,光照相关数据写入G-BUFFER(坐标、法线、UV、反射系数等等)
		第二次渲染
			遍历屏幕像素,针对有效的像素点读取G-BUFFER数据进行光照计算,更新颜色缓冲区
			Unity默认使用Standard光照模型来计算,Internal-DeferrredShading.shader
		计算流程
			MESH->VS->FS(无光)->MRT(深度、法线、颜色三个BUFFER存储光照所需信息)->FRAME_BUFFER
		GBuffer信息
			RT0,存储漫反射颜色,A通道未使用
			RT1,存储高光反射颜色,A通道存储高光指数
			RT2,存储法线方向,A通道未使用
			RT3,存储自发光+光照贴图+反射探针
	ShadowCaster
		渲染阴影映射纹理时调用该shader,没有会调用Fallback的对应shader,否则不产生阴影