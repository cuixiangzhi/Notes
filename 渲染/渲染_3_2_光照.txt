光照方程
    经验模型
        Phong
            I = 环境光 + 漫反射光 + 高光
            I = KaIa + KdId*dot(n,l) + KsIs*pow(max(0,dot(r,v)),α)
            K是反射系数,I是光照强度,n是法线方向,l是入射方向,v是视线方向,r是反射方向 α是表面粗糙度,α越小越粗糙
        BlinnPhone
            Phone模型在反射方向和观察方向夹角超过90度,也就是观察方向趋向平行表面时,Phong会发生突变,BlinnPhong更接近真实情况
            pow(dot(n,h),α),h是l和v的半角向量,v在趋向于平行表面过程中h与n的夹角始终在90度之内,也就是边缘有一个渐变过程
    物理模型
    	公式原理以及输入参数
            https://www.cnblogs.com/timlly/p/10631718.html
            https://zhuanlan.zhihu.com/p/35495074
            http://artisaverb.info/PBT.html
            终极公式
                反射方程
                    Lo(p,wo) = ∫(fdkd+fs)Li(p,wi)dot(n,wi)dwi
                    fr(l,v)分为diffuse和specular两部分,采用不同的公式
                IBL漫反射
                    1.设置环境贴图HDRCubeMap
                    2.半球采样,针对每个采样方向加和计算Lo,生成diffuse和lightmapuv
                    3.根据UV采样LightMap即可
                    4.运行时积分性能不足,采样球谐函数和光照探针近似模拟
                IBL镜面反射
                    1.计算环境反射贴图HDRCubeMap,可以设置多个,生成到ReflectionProbe中存储
                    2.根据观察方向和法线计算反射方向,根据反射方向采样CudeMap
                    3.根据采样结果和反射方程计算反射颜色,预计算需要表面粗糙度来计算DG,F项运行时计算
            输入参数
                Albedo贴图
                    一定没有光照和阴影的颜色信息,金属HSB亮度范围是72.9-100,非金属HSB亮度范围是19.6–95.2
                    对于非金属,Albedo表示表面颜色,对于金属,Albedo表示基础反射率,非金属不应该包含光影信息(没有亮度渐变)
                    Albedo有真实的参考值
                Metallic贴图
                    一定是接近黑白图的,一个金属材质的金属度一定是接近1的,非金属一定是接近0的,加了金属度背光面会发黑
                Smoothness贴图
                    光滑度贴图,比较直观,用1-光滑度得出粗糙度,可以任意设置,主要表现划痕、磨损等细节
                Normal贴图
                    一定是偏蓝色的,存储了切线空间的法线信息
                AO贴图
                    烘焙的AO贴图存储了静态物体的表面环境光的遮挡情况
        具体实现
            灯光颜色
                精准光源只会在一个方向对辐照度有贡献,其他方向都是0,灯光颜色和强度用来表示入射辐射率Li
                直接光
                    实时计算,由于强度、距离、阴影、环境遮挡的影响会发生衰减
                    directlight.color *= shadow*atten*ao
                间接光
                    静态物体通过LightMap直接读取,动态物体通过SH函数计算
                    indirect.diffuse = (sh|lightmap) * ao
                    indirect.specular = envirmap * ao
            反射比例
                ks=lerp(vec3(0.04),albedo.rgb,metallic)
                kd=lerp(vec(0.96),0,metallic)
            漫反射BRDF
                diffTerm = albedo/π
                diffTerm = albedo/π * (1+(Fd-1)(1-dot(n,l))⁵*(1+(Fd-1)(1-dot(n,v))⁵)) Fd=0.5+2m(n,l)²
            镜面反射BRDF
                D=rough²/π*[dot(n,h)²*(rough²-1)+1]²
                F=F0+(1-F0)(1-dot(n,v))⁵ F0=ks
                G=Gs(n,v,k)*Gs(n,l,k) Gs=dot(n,v)/[dot(n,v)(1-k)+k] 直接光k=(rough+1)²/8 间接光k=rough²/2
                denom = 4 * max(0,dot(n,v)) * max(0,dot(n,l))
                specTerm = DFG / denom
            终极结果
                直接光 diff = diffTerm * light.color * dot(n,l) * kd
                直接光 spec = specTerm * light.color * dot(n,l)
                间接光 diff = indirect.diffuse * kd * albedo
                间接光 spec = indirect.specular * F
光照探头
    LightProbe
        给动态物体提供间接光,避免实时补光的方式来提高角色的亮度
        添加间接光的采样点(LightProbe),记录场景的间接光信息
        采样点把整个空间分割为一个个四面体,物体在一个四面体内根据权重获取不同采样点的影响程度
        采样点尽量布置在光照变化较大的地方(进入阴影的地方)
        LightmapSettings.lightProbes.bakedProbes可以获取烘焙后的信息
    ReflectionProbe

光照模式
    Realtime
        直接光实时计算,阴影使用ShadowMap计算(ShadowMap只计算ShadowDistance以内的动态对象)
        RealtimeGI计算静态物体表面所有可能的反射光线,运行时动态计算间接光
        IndirectMultiplier在强度不是0并且不开启RealtimeGI时会把间接光烘焙到LightMap
    Mixed
        BakeIndirect
            直接光实时计算,间接光存储在LightMap和LightProbes,阴影使用ShadowMap计算
        ShadowMask
            直接光实时计算,间接光存储在LightMap和LightProbes,阴影使用ShadowMask(最多4个Mixed光源,存储直接光被静态物体遮挡信息)
                            动态物体Receive     静态物体Receive
            动态物体Cast    ShadowMap           ShadowMap+ShadowMask
            静态物体Cast    LightProbes         ShadowMask
        Subtractive
            直接光、间接光、阴影烘焙到LightMap和LightProbes
                            动态物体Receive     静态物体Receive
            动态物体Cast    ShadowMap           主光ShadowMap+DistanceLightMap
            静态物体Cast    LightProbes         ShadowMask
    Baked
        直接光、间接光、阴影烘焙到LightMap和LightProbes,只对静态物体生效,LightProbes对动态物体生效
渲染路径
	Forward
		MESH->VS->FS(光照计算)->FRAME_BUFFER
		ForwardBase: 
			#pragma multi_compile_fwdbase
			计算自发光、环境光、主平行光、SH光、光照贴图、阴影
			Unity中设置为NotImporant的光会被按照逐顶点或者SH处理
			逐顶点光照计算 Shade4PointLights(...) unity_4LightPosXYZColorAtten
			球谐光照计算 
		ForwardAdd:  
			Blend One One 
			#pragma multi_compile_fwdadd
			计算额外的逐像素光源,AddPass会根据照亮该物体的光源数量被执行多次
			照亮每个物体的逐像素光源个数有限制,Unity会根据光源的类型及对物体的影响程度(距离、强度、类型等)进行排序
			_LightColor0和_WorldSpaceLightPos0存储当前逐像素光源的颜色和位置
		光源信息
			Unity会根据当前光源类型为PASS的执行设置对应的光源属性 位置、颜色、衰减纹理、变换矩阵
			获取光的方向 
				UnityWorldSpaceLightDir(i.worldPos)
			获取光的颜色 
				_LightColor0
			获取光的衰减 
				平行光为 atten=1
				其它类型 
						lightSpacePos=mul(_LightMatrix0,i.worldPos).xyz	
						attenUV=dot(lightSpacePos,lightSpacePos).xx
						atten=tex2D(_LightTexture0,attenUV).UNITY_ATTEN_CHANNEL;
				直接获取 
						UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos)
	Deferred
		第一次渲染
			不计算光照信息,只进行深度测试,光照相关数据写入G-BUFFER(坐标、法线、UV、反射系数等等)
		第二次渲染
			遍历屏幕像素,针对有效的像素点读取G-BUFFER数据进行光照计算,更新颜色缓冲区
			Unity默认使用Standard光照模型来计算,Internal-DeferrredShading.shader
		计算流程
			MESH->VS->FS(无光)->MRT(深度、法线、颜色三个BUFFER存储光照所需信息)->FRAME_BUFFER
		GBuffer信息
			RT0,存储漫反射颜色,A通道未使用
			RT1,存储高光反射颜色,A通道存储高光指数
			RT2,存储法线方向,A通道未使用
			RT3,存储自发光+光照贴图+反射探针
	ShadowCaster
		渲染阴影映射纹理时调用该shader,没有会调用Fallback的对应shader,否则不产生阴影