Albedo
    对于金属部分Albedo表示反射率,对于非金属表示BaseColor
Metalness
    金属度单通道贴图,值一般都是0或1
Smoothness
    光滑度单通道贴图,用来计算BRDF中的DFG
AmbientOcclusion
    环境光遮挡贴图,用于计算表面接收到的光的遮挡情况
NormalMap
    原理
        1.法线贴图存储的法线是切线空间下的一个向量
            1.根据UV和POS计算出的切线和法线可能不是垂直的 T=normalize(T-dot(T,N)*N) T减去T在N上的投影
            2.已知世界坐标系下的切线T和法线N(顶点属性),叉乘可得B
            3.TBN行矩阵等价于WorldToTangent(正交矩阵的转置等价于逆矩阵)
        2.法线贴图存储的RGB范围是[0,1],而法线范围是[-1,1]
            rgb=normal*0.5+0.5 normal=rgb*2-1 对应CGINC内的UnpackNormal函数
            法线贴图法线不会偏移Z轴太远,因此法线贴图都是偏蓝色的
ParallaxMap
    原理
        1.视线e和凸起的表面真实交点是a,e的延长线与地面的交点为b,此时观察b点的颜色应该用a点的属性来计算
            1.把高度图分成N层,视线与每一层有一个交点,真实交点a位于其中两层之间,分割层数越多越精细,采样次数也越多
            2.从低到高求解视线与分割线交点,检查交点和对应位置高度图的大小,比高度图高的第一个点就是近似的a点
            3.最简单的计算是假设ba向量长度等于b点的高度,在切线空间下计算a点uv偏移
        2.法线贴图只是通过修改像素的法线方向来调整表面的明暗效果,没有真实的遮挡关系
CubeMap
    纹理映射
        1.根据方向向量得出最大维度所在方向的纹理
        2.其它两个维度除以最大维度,缩放到[-1,1]
        3.通过n*0.5+0.5把纹理坐标映射到[0,1]之内
    反射折射
        1.texCUBE(reflect(-v,n))
        2.texCUBE(refract(-v,n,ratio))
    BoxProjection
        1.CubeMap采样的uvw向量是从CUBE中心点指向采样点的
        2.视线向量需要经过计算转换为正确的uvw向量(向量与aabb碰撞检测)
        3.根据v+t*d=边界计算射线与AABB交点,根据交点和CUBE中心点计算uvw 
RenderTexture
    渲染纹理,包含一个ColorBuffer和一个DepthBuffer,DepthBuffer包含16位depth和8位stencil
ProcedureTexture
    程序纹理,使用数学公式定义的纹理,不占内存但是需要大量计算
LightMap
    光照贴图,存储了针对静态物体的间接光照信息,利用光线追踪算法使用HDRCudeMap作为光源生成
纹理采样
    概念
        采样点:渲染目标光栅化之后的像素点
        原始信号:渲染所目标使用的纹理
    最近点
        采样1次,例如纹理坐标映射后为(89.6,70.4),那么直接取(89,70)
    双线性
        采样4次,例如纹理坐标映射后为(89.6,70.4),那么先获取(89,70)、(90,70)、(89,71)、(90、71)四个像素的值之后按比例进行线性插值
    三线性
        采样8次,分别在两个mipmap下执行双线性采样,然后再对mipmap做加权平均,mipmap是按照pixel的属性变化率来计算的
    各向异性
        线性采样只考虑了表面平行于屏幕,此时uv两个方向的纹素比例是一致的,当表面有一定倾斜角度时,uv比例发生变化
        AF是按照uv比例在两个方向采样不同的次数进行加权平均,4x采样32次,16x采样128次
        AF是在三线性的基础上进行采样的,因此在mipmap变化的地方比三线性更清晰
    MipMap计算
        ddx&ddy通过pixel quad内的4个像素的纹理坐标变化率来得出mipmap等级
        首先根据纹理宽高计算出uv=i.uv*texture.wh
        然后求出UV方向的偏导数和最大变化率 dx=ddx(uv) dy=ddy(uv) L=max(sqrt(dot(dx,dx)), sqrt(dot(dy,dy)))
        最后利用对数函数求解D = log2(L)
纹理压缩
    文件存储压缩格式
        基于整幅图片进行压缩,不支持分块解压,无法利用GPU并行功能
        psd tga bmp png jpg gif
    内存存储压缩格式
        DXT
            把整张纹理分成4*4的小块,每个块保留两个16位的颜色,16个像素通过公式差值得出原始的颜色,每个块需要64位
            DXT算法对每个4*4block进行压缩,只保留两个颜色,其他颜色值这两个颜色之间的插值
            DXT1压缩比为0.3 DXT5压缩比为0.6
        ETC
            安卓常用压缩算法,ETC1不支持ALPHA通道,4*4块压缩
            ETC2RGBA压缩比为1:4,ETC2RGB压缩比为1:8,GLES3.0支持
        PVR
            IOS常用压缩算法,压缩分块时会考虑部分块之间的关联性
            PVRTC2是8*4压缩,压缩比为1:8
            PVRTC4是4*4压缩,压缩比为1:4
        ASTC
            IOS6以后支持的压缩算法,不需要POT支持,压缩质量比PVRTC更高
            ASTC压缩比为4x4=1:4 5x5=1:6.25 6x6=1:9 8x8=1:16 10x10=1:24.97 12x12=1:35.93