基础
    降采样
        对一幅M*N的图像进行s倍的降采样,得到一张(M>>s)*(N>>s)的图像,原图中s*s个像素合并为一个像素
    深度差
        根据屏幕深度的差和阈值来判断是否距离很近,在Soft粒子上有应用
        ComputeScreenPos计算齐次视口坐标->tex2DProj+LinearEyeDepth获取不透明物体深度->ObjectToView计算透明物体深度
    颜色差
        根据相邻像素颜色的差异突变判断图像边缘
    亮度差
        根据相邻像素亮度的差异突变判断图像边缘
描边
    边缘发光
        利用视线和法线的点乘计算边缘,模型越边缘的地方点乘越接近0,用1减去点乘结果作为边缘光的强度
        对边缘光的强度做一个菲涅尔处理,再乘上边缘光颜色,作为自发光叠加到原始颜色上
            1.rimValue = 1-saturate(dot(N,V));
            2.rimValue = pow(rimValue,rimPow);
            3.emission = rimColor * rimValue;
    法线外扩
        第一次渲染背面,Cull Front & ZWrite Off,在裁剪空间对XY沿着法线方向增大一圈
            1.clipPos = mul(MVP,v.vertex); 
            2.viewNormal = mul(IT_MV,v.normal);
            3.clipNormal = mul(P,viewNormal.xy);
            4.clipPos.xy += clipNormal.xy * outline;
        第二次正常渲染,Cull Back,正常计算颜色即可
后期
    SSAO
    Bloom
    Grain
    DepthOfField
    ColorGrading
    MotionBlur
波纹
    原理:UV动画,屏幕每个像素的UV坐标以中心点为圆心,向圆外偏移,根据距离中心点的距离和偏移的时间计算偏移程度
    顶点shader: 
        普通的vertex变换和uv赋值
    像素shader:
        首先计算出圆心指向当前UV的向量(x方向乘以宽高比,确保波纹是圆形的) 
            dv = (i.uv - fixed2(0.5,0.5)) * (_ScreenParams.x/_ScreenParams.y,1)
        然后计算波纹震动程度
            factor = a*sin(w)  
            a是振幅,从中心到边缘逐渐减弱,a=lerp(ARG_A,0,curOffset/maxOffset) ARG_A=0.1
            w是相位,w=频率*(passedTime+offset*3)
        接着计算波纹波动范围
            波动的中心 center = moveSpeed*passedTime
            波动的范围 range
            波动的偏移 offsetFactor = clamp(range-abs(center-offset),0,1) / range,避免波动范围内的明显的边界
            波动的比例 factor = factor * offsetFactor
        最后计算扩散后的UV坐标 uv = uv + dv * factor    
场景
    草树
    云雾
    镜子
    头发
    皮肤
    昼夜