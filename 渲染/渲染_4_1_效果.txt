基础
    降采样
        对一幅M*N的图像进行s倍的降采样,得到一张(M>>s)*(N>>s)的图像,原图中s*s个像素合并为一个像素
    深度差
        根据屏幕深度的差和阈值来判断是否距离很近,在Soft粒子上有应用
        ComputeScreenPos计算齐次视口坐标->tex2DProj+LinearEyeDepth获取不透明物体深度->ObjectToView计算透明物体深度
    颜色差
        根据相邻像素颜色的差异突变判断图像边缘
    亮度差
        根据相邻像素亮度的差异突变判断图像边缘
场景渲染
    地形
    植被
    云雾
    水面
    昼夜
角色渲染
    描边
        边缘发光
            利用视线和法线的点乘计算边缘,模型越边缘的地方点乘越接近0,用1减去点乘结果作为边缘光的强度
            对边缘光的强度做一个菲涅尔处理,再乘上边缘光颜色,作为自发光叠加到原始颜色上
                1.rimValue = 1-saturate(dot(N,V));
                2.rimValue = pow(rimValue,rimPow);
                3.emission = rimColor * rimValue;
        法线外扩
            第一次渲染背面,Cull Front & ZWrite Off,在裁剪空间对XY沿着法线方向增大一圈
                1.clipPos = mul(MVP,v.vertex); 
                2.viewNormal = mul(IT_MV,v.normal);
                3.clipNormal = mul(P,viewNormal.xy);
                4.clipPos.xy += clipNormal.xy * outline;
            第二次正常渲染,Cull Back,正常计算颜色即可
        边缘检测(亮度)
            利用Sobel算子计算水平和垂直方向的偏导数,然后计算梯度长度,根据指定阈值得出边缘
                水平|-1 0 1| 垂直|-1 -2 -1|
                    |-2 0 2|     | 0  0  0|
                    |-1 0 1|     | 1  2  1|
            顶点shader
                计算sobel算子所需要的9个uv坐标
            像素shader
                计算出亮度值并分别求和计算Gx、Gy
                计算出梯度向量的长度,和指定阈值比较得出边缘
        边缘检测(深度)

    皮肤
    头发
后期特效
    SSAO
    ColorGrading-
    雨雪天气
    景深效果
    运动模糊
        原理:摄像机原理(拍摄100帧,每4帧叠加,最终为25帧),对连续的几帧图像进行累加
        实现:
            游戏不可能实时渲染N倍的帧,效果可能不够真实
            可以利用一张RT存储上一帧的结果和当前帧做混合
            也可以利用几张纹理对特定物体进行处理模拟运动模糊效果
            或者利用2张RT计算像素的移动速度进行模糊
        顶点shader
            普通vertex变换
        像素shader
            pass 
                使用指定的模糊程度作为源像素的alpha值
                Blend SrcAlpha OneMinusSrcAlpha
                ColorMask RGB
            pass
                使用源像素的alpha作为源像素的alpha值
                Blend One Zero
                ColorMask A
            pass
                
    辉光效果
        原理:先利用亮度提取出超过指定阈值的部分,然后对其做高斯模糊处理,最后叠加到原图上
        需要4张RT,SRC->TMP0提取高亮部分,TMO0->TMP1->TMP0水平和垂直模糊,,SRC->DST用TMP0叠加得出最终结果
        顶点shader
            普通vertex变换
        像素shader
            模糊计算 加权平均
            提取计算 亮度阈值 col *= clamp(luminance(c) - _LuminanceThreshold,0,1)
            叠加计算 直接相加 tex2D(SRC) + tex2D(TMP0)
    高斯模糊
        原理:利用高斯分布公式对周围像素点做加权平均 G(x,y)=(1/2πσ²)exp(-(x²+y²)/2σ²),方差σ可以取1
        需要4张RT,SRC->TMP0,TMO0->TMP1->TMP0水平和垂直模糊,TMP0->DST得出最终结果
        顶点shader
            由于对称性可以只计算出中心点和横向左半部分的像素UV
            高斯模糊可以分成两部分做叠加,也就是先做水平方向模糊,在对模糊后的图像做垂直方向模糊
        像素shader
            根据高斯核采样像素点加权平均,得出最终结果
    屏幕亮度
        原理:RGB颜色模型与HSV颜色模型转换
        顶点shader:
            普通的vertex变换和uv赋值
        像素shader:
            texColor = tex2D(i.uv,_MainTex)
            亮度修改,直接乘以亮度系数即可  
                finalColor = texColor * _Brightness
            饱和度修改,先计算出相同亮度(YUV颜色模型)下饱和度为0的灰色,然后根据饱和度和finalColor做插值
                luminance = dot(texColor.rgb,fixed3(0.2125,0.7154,0.0721)或者fixed3(0.299,0.587,0.114))
                luminanceColor = fixed3(luminance,luminance,luminance)
                finalColor = lerp(luminanceColor,finalColor,_Saturation)
            对比度修改,灰度区间从[A,B]变换到[C,D]
                contrastColor = fixed3(0.5,0.5,0.5)
                finalColor = lerp(contrastColor,finalColor,_Contrast)
    屏幕波纹
        原理:UV动画,屏幕每个像素的UV坐标以中心点为圆心,向圆外偏移,根据距离中心点的距离和偏移的时间计算偏移程度
        顶点shader: 
            普通的vertex变换和uv赋值
        像素shader:
            首先计算出圆心指向当前UV的向量(x方向乘以宽高比,确保波纹是圆形的) 
                dv = (i.uv - fixed2(0.5,0.5)) * (_ScreenParams.x/_ScreenParams.y,1)
            然后计算波纹震动程度
                factor = a*sin(w)  
                a是振幅,从中心到边缘逐渐减弱,a=lerp(ARG_A,0,curOffset/maxOffset) ARG_A=0.1
                w是相位,w=频率*(passedTime+offset*3)
            接着计算波纹波动范围
                波动的中心 center = moveSpeed*passedTime
                波动的范围 range
                波动的偏移 offsetFactor = clamp(range-abs(center-offset),0,1) / range,避免波动范围内的明显的边界
                波动的比例 factor = factor * offsetFactor
            最后计算扩散后的UV坐标 uv = uv + dv * factor   