模糊
    降采样
        对一幅M*N的图像进行s倍的降采样,得到一张(M>>s)*(N>>s)的图像,原图中s*s个像素合并为一个像素
        原图大小为M*N,渲染目标大小为M>>s*N>>s,在目标上渲染一个全屏MESH
场景
    昼夜
    水面
        波纹
            原理:UV动画,屏幕每个像素的UV坐标以中心点为圆心,向圆外偏移,根据距离中心点的距离和偏移的时间计算偏移程度
            顶点shader: 
                普通的vertex变换和uv赋值
            像素shader:
                首先计算出圆心指向当前UV的向量(x方向乘以宽高比,确保波纹是圆形的) 
                    dv = i.uv - fixed2(0.5,0.5) * (_ScreenParams.x/_ScreenParams.y,1)
                    offset = |dv|
                然后计算波纹震动程度
                    factor = a*sin(w)  
                    a是振幅(偏移在0.05左右效果不错),a和offset相关时可以限制边界处幅度,例如a=(1-offset)*0.1
                    w是震频(单位时间内的震动次数),w和时间相关,例如w=频率*(passedTime+offset*3)
                接着计算波纹波动范围
                    波动的中心 center = moveSpeed*passedTime
                    波动的范围 range
                    波动的偏移 offsetFactor = clamp(range-abs(center-offset),0,1) / range,避免波动范围内的明显的边界
                    波动的比例 factor = factor * offsetFactor
                最后计算扩散后的UV坐标 uv = uv + dv * factor
        流动
            原理:法线贴图UV动画
    草树
    云雾
    石头
    木头
    建筑
    地面
    镜子
    玻璃
角色
    描边
        法线外扩方案
            原理:使用两个Pass,一个渲染正面,一个渲染背面,背面的顶点沿着法线方向偏移一定距离
            缺点:如果边缘有比较明显的棱角,描边会不连贯
            背面Pass
                Cull Front
                ZWrite Off
                顶点shader
                    在模型空间和世界空间进行变换会沿着各个方向扩大一圈
                    在视图空间下可以控制顶点沿着XY方向扩大
                    法线变换矩阵是顶点变换矩阵的逆转置矩阵
                    o.vertex = mul(UNITY_MATRIX_MV,v.vertex)
                    float3x3 viewNormal = mul((float3x3)UNITY_MATRIX_IT_MV,v.normal)
                    o.vertex.xy = o.vertex.xy + viewNormal * outline
                    o.vertex = mul(UNITY_MATRIX_P,o.vertex)
                像素shader
                    返回描边颜色即可,因为内部会被正面PASS覆盖
            正面PASS
                Cull Back
                正常渲染即可
        后处理方案
            原理:通过RT生成描边图,然后叠加到正常渲染的图上去
                1.生成纯色图片
                2.模糊算法对纯色图片进行模糊
                3.模糊图片减去纯色可得到边缘色的图片
                4.叠加到正常的图上
            实现
                OnPreRender渲染纯色图片
                    camera.cullingmask = outline_mask
                    camera.targetTexture = render_texture
                    camera.renderwithshader(outline_shader_pre,"")
                    shader直接返回纯色
                OnRenderImage模糊纯色图片
                    首先模糊纯色图片
                        Graphics.Blit(render_texture,temp1)
                        Graphics.Blit(temp1,temp2,outline_shader,0) 水平模糊
                        Graphics.Blit(temp2,temp1,outline_shader,1) 垂直模糊
                    此时原图为render_texture,模糊图片为temp1
                        Graphics.Blit(source,destination,outline_shader,2) 模糊颜色减去纯色
                    shader分为3个pass
                        pass0和pass1使用高斯模糊算法,加权平均得出颜色
                        pass2执行相减和叠加操作
                        tex2D(MAIN,o.uv)+saturate(tex2D(BLUR)-tex2D(SRC))
    头发
    身体
    眼睛
    脸部
    武器
特效
    广告牌
后期
    边缘检测
    高斯模糊
    运动模糊
    景深
    Bloom
    屏幕水波
卡通
半透