模糊
    降采样
        对一幅M*N的图像进行s倍的降采样,得到一张(M>>s)*(N>>s)的图像,原图中s*s个像素合并为一个像素
        原图大小为M*N,渲染目标大小为M>>s*N>>s,在目标上渲染一个全屏MESH
描边
    边缘发光
        利用视线和法线的点乘计算边缘,模型越边缘的地方点乘越接近0,用1减去点乘结果作为边缘光的强度
        对边缘光的强度做一个菲涅尔处理,再乘上边缘光颜色,作为自发光叠加到原始颜色上
            1.rimValue = 1-saturate(dot(N,V));
            2.rimValue = pow(rimValue,rimPow);
            3.emission = rimColor * rimValue;
    法线外扩
        第一次渲染背面,Cull Front & ZWrite Off,在裁剪空间对XY沿着法线方向增大一圈
            1.clipPos = mul(MVP,v.vertex); 
            2.viewNormal = mul(IT_MV,v.normal);
            3.clipNormal = mul(P,viewNormal.xy);
            4.clipPos.xy += clipNormal.xy * outline;
        第二次正常渲染,Cull Back,正常计算颜色即可
    后期处理
        首先渲染纯色图片,并对图片做模糊处理扩大物体边缘
        然后正常渲染模型
        最后做一次后处理,叠加三张图片(正常结果、纯色结果、模糊结果)
            OnPreRender渲染纯色图片
                camera.cullingmask = outline_mask
                camera.targetTexture = render_texture
                camera.renderwithshader(outline_shader_pre,"")
                shader直接返回纯色
            OnRenderImage模糊纯色图片
                首先模糊纯色图片
                    Graphics.Blit(render_texture,temp1)
                    Graphics.Blit(temp1,temp2,outline_shader,0) 水平模糊
                    Graphics.Blit(temp2,temp1,outline_shader,1) 垂直模糊
                此时原图为render_texture,模糊图片为temp1
                    Graphics.Blit(source,destination,outline_shader,2) 模糊颜色减去纯色
                shader分为3个pass
                    pass0和pass1使用高斯模糊算法,加权平均得出颜色
                    pass2执行相减和叠加操作
                    tex2D(MAIN,o.uv)+saturate(tex2D(BLUR)-tex2D(SRC))
波纹
    原理:UV动画,屏幕每个像素的UV坐标以中心点为圆心,向圆外偏移,根据距离中心点的距离和偏移的时间计算偏移程度
    顶点shader: 
        普通的vertex变换和uv赋值
    像素shader:
        首先计算出圆心指向当前UV的向量(x方向乘以宽高比,确保波纹是圆形的) 
            dv = i.uv - fixed2(0.5,0.5) * (_ScreenParams.x/_ScreenParams.y,1)
            offset = |dv|
        然后计算波纹震动程度
            factor = a*sin(w)  
            a是振幅(偏移在0.05左右效果不错),a和offset相关时可以限制边界处幅度,例如a=(1-offset)*0.1
            w是震频(单位时间内的震动次数),w和时间相关,例如w=频率*(passedTime+offset*3)
        接着计算波纹波动范围
            波动的中心 center = moveSpeed*passedTime
            波动的范围 range
            波动的偏移 offsetFactor = clamp(range-abs(center-offset),0,1) / range,避免波动范围内的明显的边界
            波动的比例 factor = factor * offsetFactor
        最后计算扩散后的UV坐标 uv = uv + dv * factor    
场景
    草树
    云雾
    镜子
    玻璃
    头发
    皮肤
    Bloom
    昼夜