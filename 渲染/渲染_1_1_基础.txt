图形
	渲染指令调用顺序
		应用程序->操作系统->驱动程序->显卡
	多线程渲染
		逻辑线程和渲染线程分离,使用CommandBuffer产生和消耗渲染命令
		逻辑线程更新帧N,渲染线程渲染帧N-1,逻辑帧N结束后等待渲染帧结束再开始下一帧计算
	渲染状态
		基本状态 Cull AlphaTest Offset Ztest ZWrite Blend ColorMask
		状态分组 queue->lightmap->distance->shader->material->pass->objects
		状态切换 根据当前分组的数据检查需要切换哪些状态
	渲染顺序
		不透明物体从前往后渲染,利用EarlyZ技术减少OverDraw
		半透明物体从后向前渲染,半透明物体不写入深度,执行AlphaBlend操作,EZ在这里也可以用
	渲染流水线
		顶点着色器(MVP变换)->曲面细分着色器->几何着色器->图元装配->CVV裁剪->透视除法->视口变换->光栅化->Early-Z优化
		片段着色器->归属测试->裁剪测试->Alpha测试->深度测试->模板测试->颜色混合
	垂直同步
		开启之后SF等待硬件的VSYNC信号,检测BACK_BUFFER的状态,如果没有或者正在传输数据,则使用上一帧的数据显示
硬件
	显卡相关
		独立显卡 集成显卡(主板) 核心显卡(CPU)
	GPU架构
		gpc     : GPU包含多个GPC单元,GPC包含多个SM单元,每个GPC都具备完整的渲染流水线执行能力
		sm      : SM是执行着色器程序的单元,包含加载存储单元、数学计算单元、寄存器、L1缓存、纹理读取单元、纹理缓存等等
		thread  : 执行shader的基本单元,每个thread都有自己独占的寄存器,多个thread打包为wrap由sm调度执行
		wrap    : 执行相同shader的一组thread,wrap会记录该组thread执行到了那条指令,wrap有固定的thread数量
		register: 寄存器的数量是固定的,GPU按照wrap执行的shader所需寄存器数量来分配,shader占用寄存器越多,wrap就越少