前言
    优化是一点点积累的
基础知识
    DynamicBatching
        运行时会把相同材质的Mesh合并为一个大Mesh,顶点限制300,总数据限制900,消耗CPU资源
    StaticBatching
        场景打包时会把使用相同材质的mesh合并为一个大Mesh
        顶点数限制64K,索引数限制64K(GLES.48K,MACOS.32K),消耗内存资源,降低CPU消耗
        Unity默认会把使用不同材质的MESH也合并在一起,可以自定义合批工具,会减少一定的批次
    GPUInstance
        每个实例引用相同的Mesh数据,Shader内通过StructArray来获取每个实例的不同数据
        数据数组有长度限制,默认500个(vulkan250个),不支持Texture结构数组
    Gfx.WaitForTargetFPS
        CPU速度很快,超出了目标帧率,例如限帧30帧,上一帧耗时15ms,那么当前帧WaitForTargetFPS=33-15=18ms
    Gfx.WaitForPresent
        CPU等待GPU渲染完成或者VSync信号到来,GPU负载很高
    Gfx.SetPass
        一个DrawCall分为setpass和batch两部分,相同的setpass也就是使用相同的材质,batch是合并的Mesh个数
        批次分类及合批影响因素
            DepthLoop
                1.自定义渲染目标可以取消这个批次,需要规范深度图使用方式,好像有一些渲染效果会出异常
            ShadowLoop
                1.Unity会根据ShadowCaster这个Pass的状态设置计算一个hash用于判断是不是相同,相同则可以执行合批
                2.影响合批的是Shader内ShadowCaster的实现和StaticBatchIndex,SkinMesh无法合批
            OpaqueLoop
                1.DistanceSort,安卓平台为了执行Early-Z优化,会优先按照距离排序,导致渲染队列内出现材质穿插现象,批次变多,CPU消耗变高,GPU消耗未知(状态切换消耗是否更高)
                2.BatchIndexSort,Unity默认的静态合批并不是按照材质球分类的,按照StaticBatchIndex排序之后渲染队列内出现穿插现象,手动指定静态合批可以减少一定批次
                3.LightmapIndexSort,静态物体同一个静态批次内会按照光照贴图来排序,光照贴图每增加一张批次数量增加一倍,尽量一张2048搞定
                4.ShadowDistance,同一个静态批次内可能会被ShadowDistance分成两部分,批次极限情况会翻一倍
                5.MaterialCount,批次数量可以用staticBatchCount * lightmapCount * 2粗略计算,材质球极限不多于50个(3张lightmap不多于30个)
            TransparentLoop
高中低配选项控制
    项目资源规范
        界面
            字体规范
                公共字体 TTF字体(1个)
            图集规范
                公共图集 2048*2048*(3~4个,1个物品图集,1个通用背景图集,1个通用小图图集)
                功能图集 1024*512|512*512*(不限制)
                特殊功能 2048*1024|1024*1024*(3~5)
                特殊背景 
                特殊图标
        角色
        场景
        特效
        音频
        视频
    机型分类规则

    可调节选项
        1.LODGroup
            使用LODGroup组件设置Render列表,根据网格占屏比选择适当的LODMESH,支持淡入淡出(unity_LODFade)
            物体占屏比是通过当前屏幕空间AABB和近平面时物体的AABB的比例值来计算
        2.ShaderLOD
            shader实现多个不同LOD的subshader,LOD越低效果越差但是性能越好,例如PBS有高中低三个版本
            shader.globalMaximumLODLevel设置当前渲染质量,低于该值的shader的pass才会被使用
            shader.maximumLodLevel设置特定shader的渲染质量
        3.QualityLevel
            运行时通过修改Unity的渲染配置,来提高质量或者降低消耗,通过QualitySettings.SetQualityLevel调节
            渲染
                PixelLightCount Important模式一定是逐像素的,Important个数小于指定个数会选取Auto模式的作为逐像素光源
                TextureQuality  降低显存占用(0级MipMap,贴图R/W一定要关闭),FullRes是完整分辨率,HalfRes是一半分辨率
                AnisoTropicTex  各向异性纹理采样是否开启,开启之后远处的细节会变清晰,PerTexture会使用贴图的设置,ForceOn会强制设置所有贴图
                AntiAliasing    MSAA抗锯齿的采样点个数,可以是2x、4x、8x,需要配合Camera的MSAA选项使用
                SoftParticles   开启之后粒子会计算深度差dz来柔化边缘(当粒子距离物体特别近的时候穿插不会出现硬边),计算需要深度图
                Resolution      通过ScreenAPI设置渲染目标分辨率或者自定义RT作为渲染目标或者使用Camera的动态分辨率选项
            阴影
                Shadows          软阴影会多一步模糊操作,可以减弱锯齿
                ShadowDistance   距离摄像机的深度值低于该值时使用实时阴影,同时该值会影响划分阴影层级的范围
                ShadowNearOffset 直接使用8个顶点计算时可能会导致更外面的物体没有产生阴影(比如高大的建筑物在视椎体外面)
                ShadowCascades   把观察体划分为N个等级,每个等级根据8个顶点和平行光方向计算正交摄像机的AABB,提高近处物体的阴影深度的精度
            其它
                BlendWeights     蒙皮顶点最多受几根骨骼影响,减少该值可以降低蒙皮计算量,提升CPU性能
                VSyncCount       关闭后Unity会全速跑Update,否则会根据同步方式sleep一段时间在执行Update,高帧率可以减少消耗
                LODBias          不同LOD级别之间切换的偏移比例,设置为1在LOD边界立即切换,数值越大高模保留距离越大
        4.GraphicsTier
            阴影
                CascadedShadows  级联阴影,根据摄像机观察范围划分N个等级分别使用不同的深度图,提高近处物体的精度
            HDR
                UseHDR&HDRMode   HDR模式总开关,HDR模式摄像机渲染帧缓冲的格式,FP16是64位,R11G11B10是32位不带A通道
                                 开启后会额外创建一个缓冲区存储HDR计算结果
        5.PostProcess
            Bloom
        6.LightmapSettings
            光照贴图大小
                LightmapResolution 每米几个像素,数值越大质量越高内存也越大
                LightmapPadding    图元之间的像素间隔,避免不同图元由于采样算法导致混合了不同物体的光照颜色(光照溢出)
                LightmapSize       控制每张贴图最大多大,超过这个数值会生成多张
                DirectionMode      是否生成间接光的贡献度最大的光方向贴图,可以制作出间接高光效果
            光照贴图质量(样本是不是指光源发射光线的数量?)
                Bounces            光线反射次数
                EnvironmentSamples 控制环境光样本数量
                DirectSamples      控制直接光样本数量
                IndirectSamples    控制间接光样本数量(室外推荐值为100)
                IndirectIntensity  控制间接光整体强度
                AmbientOcclusion   控制间接光的AO效果
                AlbedoBoost        控制间接光反射比例,默认值1是物理精确的
                Filter             模糊图片,减弱光照贴图噪点
内存方面的优化
    shaderlab
        shader_feature
            定义的变体没有使用到不会被编译
            使用#pragma shader_feature 来定义
            使用[Toggle(feature) ..]在材质上显示该选项
        multi_compile
            定义的变体都会编译
            使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
            keyword最多256个,超过这个值会报错
        variants
            宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载时间并增加内存占用
        判断是否被使用:
            shader如果单独打包,此时shader不会编译生成任何变体
            shader和材质打包,shader会根据材质的keyword信息编译生成对应的变体
            实现IPreprocessShaders接口打包时剔除变体
        强制生成变体:
            1.把shader放在always include shaders
            2.把shader放在resources内
            3.增加多余的材质,定义对应的变体keyword
            4.5.0以后版本提供的shader_variant_collection,针对每个shader指定要使用哪些keyword,把collection放在preload或者和shader打包在一起
    r/w_memory
        read/write enabled
            开启该选项的纹理、网格会在内存中存在两份(显存+内存)
        dynamic_batching
            开启之后300顶点以下的网格会强制开启R/W
    mesh_memory
        MeshCompression
            使用压缩算法减少硬盘空间占用,默认关闭
        OptimizeMeshData
            打bundle时剔除shader没有使用到的顶点属性,可以减小包体
        VertexCompression
            降低顶点属性的精度,针对300顶点以上、未开启R/W的网格生效
    component_memory
        Animator
            FBX导入时Rig不要生成Avatar(除非需要动作混合)
        Rigidbody

渲染方面的优化
    postprocess
        合并多个后处理效果
            1.使用Unity提供的PostProcessing，关闭不使用的效果
            2.使用统一的脚本管理自定义的一些效果,例如淡入淡出、屏幕水波、景深等等
    commandbuffer
        自定义颜色和深度缓冲区
            为了使用HDR,颜色图需要使用Float格式,RGB111110Float 
            为了兼容机型,深度图格式用Depth、RHalf、RFloat
            Camera.SetTargetBuffers(RenderBuffer color,RenderBuffer depth)
            有时候需要用深度图来做额外处理,而UNITY需要多渲染一次场景生成深度图
        自定义渲染命令
            CommandBuffer.Blit()->Camera.AddCommandBuffer()
            后期特效可以利用Blend命令减少内存的拷贝操作

