矩阵
    乘法
        矩阵A左乘矩阵B = AB
        矩阵A右乘矩阵B = BA
        A*B必须满足A矩阵列数==B矩阵行数,因为矩阵乘法运算为 运算结果第M行第N列=A矩阵第M行每个元素*B矩阵第N列每个元素对应相乘然后相加
        mul(A,B) 如果A是向量,那么认为A是行向量  如果B是向量,那么认为B是列向量
        第i行第j列等于左矩阵第i行向量点乘右矩阵第j列向量
    变换
        矩阵左乘原矩阵是对原矩阵进行行变换,即对列向量执行行变换(修改列向量每一行的数据)
        原矩阵右乘矩阵是对原矩阵进行列变换,即对行向量执行列变换(修改行向量每一列的数据)
    矩阵形式
        单位矩阵 
            n阶方阵对角线全1,其他元素全0
        逆矩阵
            AB相乘结果为单位矩阵,则AB互为逆矩阵
            Matrix4x4.inverse表示逆矩阵
            localToWorld和worldToLocal互为逆矩阵
        转置矩阵
            A矩阵行列互换,主要用于在计算矩阵乘法时切换左乘右乘
        正交矩阵
            逆矩阵互为转置矩阵
        坐标系变换矩阵
            在目标坐标系下定义的三个正交基向量构成的矩阵*在这个坐标系下定义的向量
    变换顺序
        缩放-旋转-平移
        localToWorld = T矩阵*R矩阵*S矩阵*列向量
        worldToLocal = S逆矩阵*R逆矩阵*T逆矩阵*localToWorld
        从左往右计算,对右矩阵执行行变换
    向量叉乘
        AxB = (AyBz-AzBy,AzBx-AxBz,AxBy-AyBx)
    齐次坐标
        N+1维向量表示N维向量,齐次坐标为(x,y,z,w) 
        w值不唯一 w=1为规格化坐标,此时(x,y,z)是普通坐标系下的坐标  w=0表示无穷远的点
        主要用于统一矩阵运算,便于变换的合成,便于硬件实现
    法线变换
        由于缩放变换可能不是等比缩放,因此MV矩阵变换之后法线可能不正确
        因此法线的MVP变换矩阵是 MV的逆转置矩阵把法线变换到视图空间,然后用从视图空间变换到CVV
        float3x3 vnormal = mul(UNITY_MATRIX_IT_MV,v.normal)
        float2x2 pnormal = mul(UNITY_MATRIX_P,vnormal)
        transpose函数用于计算转置矩阵
    基变换
        相当于计算向量在目标坐标系各个轴上的投影长度,每个轴的结果都是点乘计算
        已知A坐标系下B坐标系的各个轴的表示,把B的坐标变换到A下,只需要B的各个轴组成行矩阵*列向量
    逆矩阵和转置矩阵
        如果一个矩阵只包含平移和旋转变换,那么它的逆矩阵等于它的转置矩阵
坐标系
    切线坐标系
        UV坐标是定义于切线坐标系下的
        U坐标方向是T轴,V坐标方向是B轴,法线是N轴
        切线是根据三个顶点的UV和三角形法线计算出来的
        每个三角形都有自己的切线空间,三角形的变换不会影响切线
    模型坐标系
        局部坐标系,是指模型本身的坐标系,以物体中心为原点,有自己的xyz轴
        默认放入世界坐标系的模型,局部坐标系和世界坐标系是重合的
        经过M矩阵变换转换到世界坐标系
    世界坐标系
        左手坐标系 x右y上z里
        右手坐标系 x右y上z内
        经过V矩阵变换转换到视图坐标系
    视图坐标系
        摄像机局部坐标系
        经过P矩阵转换到裁剪坐标系
    裁剪坐标系
        透视除法之前的坐标系,此时还保留有深度信息
        经过透视除法转换到NDC坐标系
    设备坐标系
        范围从-1到1,经过视口变换转换为视口坐标
        Z值范围根据平台不同有区别,DX和METAL范围是[0,1]
    屏幕坐标系
        unity中左下角为(0,0) 右上角为显示屏幕的(w,h)
        ngui中中心点为(0,0)
        gui左上角为(0,0)
        glut窗口左上角为(0,0)
    窗口坐标系
        屏幕坐标系下的一个子窗口,可以缩放移动关闭,与glut中的window概念一致 
        xy标记起始点,wh标记宽高 xywh均是整数,以屏幕分辨率为基准
    视口坐标系
        视口是窗口的一个区域,是真正的显示当前摄像机渲染结果的区域
        xy标记起始点,wh标记宽高 xywh均是0-1的数值,是窗口大小的比例
变换
    模型变换
        平移变换              
           |1 0 0 tx|   |1 0 0 -tx|  
           |0 1 0 ty|   |0 1 0 -ty|
           |0 0 1 tz|   |0 0 1 -tz|
           |0 0 0  1|   |0 0 0  1|    
        缩放变换
           |s 0 0 0|   |1/s 0   0    0|  
           |0 s 0 0|   |0   1/s 0    0|
           |0 0 s 0|   |0   0   1/s  0|
           |0 0 0 1|   |0   0   0    1|    
        旋转变换
            2D旋转 
                未旋转时,长度为r,与x轴夹角为d1,绕原点旋转角度d2
                (x,y) = rcosd1,rsind1  (x',y') = rcos(d1+d2),rsin(d1+d2)
                简化后 x'=rcosd1*cosd2-rsind1*sind2=xcosd2-ysind2  y'=rsind1cosd2+rcosd1sind2=ycosd2+xsind2
                旋转矩阵
                    |cos0 -sin0 0||x|
                    |sin0  cos0 0||y|
                    |0     0    1||1|
                绕任意点的旋转需要先平移到原点,T正 * R * T逆 * 列向量
            3D旋转
                绕某个轴逆时针旋转可以简化为在另外两个轴组成的平面上进行2D旋转,下述矩阵均在右手坐标系下计算
                    绕X轴旋转,x值不变 yoz平面 从x轴正向朝向原点看去逆时针旋转为正角度旋转,左手坐标系下z轴相反,对应正弦余弦变换符号即可
                        |1 0     0    0||x|
                        |0 cos0 -sin0 0||y|
                        |0 sin0  cos0 0||z|
                        |0 0     0    1||1|
                    绕y轴旋转,y值不变 zox平面 从y轴正向朝向原点看去逆时针旋转为正角度旋转,左手坐标系下z轴相反,对应正弦余弦变换符号即可
                        |1 cos0   sin0  0||x|
                        |0 1      0     0||y|
                        |0 -sin0  cos0  0||z|
                        |0 0      0     1||1|
                    绕z轴旋转,z值不变 xoy平面 从z轴正向朝向原点看去逆时针旋转为正角度旋转,左手坐标系下z轴相反,对应正弦余弦变换符号即可
                        |1 cos0 -sin0 0||x|
                        |0 sin0  cos0 0||y|
                        |0 0     1    0||z|
                        |0 0     0    1||1|
                    使用欧拉角旋转时矩阵的计算顺序影响最终结果
                任意轴旋转
                    首先旋转旋转轴使其与坐标轴重合,在进行旋转然后在转回去
                    已知顶点(x,y,z)
                        1.yoz平面投影点为(0,y,z),yoz平面(y,z)向量与z轴夹角即为绕x轴旋转的角度
                        2.第一步旋转后旋转轴旋转到了zox平面,此时绕y轴旋转角度与z轴重合
                        3.绕z轴旋转真实角度
                        4.绕y轴逆旋转,绕x轴逆旋转
                    变换顺序 x轴->y轴->z轴->y轴逆->x轴逆,最终得出一个绕任意轴的旋转矩阵(很复杂)
                    绕任意轴的旋转需要执行很多三角函数
            欧拉角
                记录了分别绕三个轴的旋转角度,unity中使用z轴x轴y轴的旋转顺序来进行变换
                pitchX轴 yawY轴 rollZ轴
                万向节锁:zxy旋转顺序时,中间的旋转角度如果是90度,此时第一个轴和第三个轴重合,第一个轴的旋转可以利用第三个轴旋转一定角度得到
                欧拉角无法平滑差值,因为旋转每次都是从(0,0,0)开始按顺序旋转,跟当前状态没有任何关系
                旋转矩阵很复杂,有很多三角函数计算
            四元数
                旋转轴向量为(vx,vy,vz) 旋转角度为0 轴角表达式为(vx,vy,vz,0),轴角表达方式无法直接应用于变换,必须转换为矩阵或者四元数
                四元数是经过处理的轴角表达式, quaternion = (vx*sin(0/2),vy*sin(0/2),vz*sin(0/2),cos(0/2))
                乘法
                    四元数p*四元数q: 
                        4D向量叉乘,先旋转q在旋转p
                            w' = w * rkQ.w - x * rkQ.x - y * rkQ.y - z * rkQ.z,
                            x' = w * rkQ.x + x * rkQ.w + y * rkQ.z - z * rkQ.y,
                            y' = w * rkQ.y + y * rkQ.w + z * rkQ.x - x * rkQ.z,
                            z' = w * rkQ.z + z * rkQ.w + x * rkQ.y - y * rkQ.x
                        4D向量点乘,两个旋转角度之差(-1,1)
                    四元数p*向量v:   
                        常规算法
                            向量v旋转p
                            向量使用四元数表示为(x,y,z,0)
                            q*v=q*v扩展*q逆
                        OGRE算法
                            Vector3 uv, uuv;
                            Vector3 qvec(x, y, z);
                            uv = qvec.crossProduct(v);
                            uuv = qvec.crossProduct(uv);
                            uv *= (2.0f * w);
                            uuv *= 2.0f;
                            return v + uv + uuv;
                共轭
                    四元数的模^2=x^2+y^2+z^2+w^2
                    旋转轴取负即可得出共轭四元数,相当于旋转轴反向
                    旋转轴的共轭/模=四元数的逆
                差值
                    slerp(p,q,percent)
                转换
                    四元数<-->欧拉角 四元数<-->旋转矩阵
        组合变换
            已知的是模型顶点在模型坐标系下的坐标(x,y,z,1)
            该顶点变换到世界坐标系下列向量=TRS*列向量,递归计算父结点T父R父S父,得出localToWorld矩阵
    视图变换    
        视图坐标系是右手坐标系,因此Z轴方向需要使用摄像机朝向的反方向
        视图->世界矩阵如下,世界->视图求其逆矩阵
        |vxx vxy -vxz|
        |vyx vyy -vyz|
        |vzx yvz -vzz|
    投影变换
        投影变换把坐标变换到了裁剪坐标系(CVV)(-1,1) DX(0,1)
        透视投影 fov(视角) aspect(屏幕宽高比) n(近裁面到原点距离) f(远裁面到原点距离)
            投影坐标
                顶点坐标v=(x,y,z)
                投影坐标v'=(-nx/z,-ny/z,-(az+b)/z)
                X方向
                    映射到CVV范围内是从[-w/2,w/2]->[-1,1]
                    -nx/z的范围是[-w/2,w/2] w = h*aspect = 2n*tan(fov/2)*aspect
                    变换系数为 (-n/z)/(w/2) = cot(fov/2) / aspect / -z
                    齐次坐标系数为 cot(fov/2) / aspect
                Y方向
                    映射到CVV范围内是[-h/2,h/2]->[-1,1]
                    -ny/z的范围是[-h/2,h/2] h = 2n*tan(fov/2)
                    变换系数为 (-n/z)/(h/2)= cot(fov/2) / -z
                    齐次坐标系数为 cot(fov/2)
                Z方向
                    映射到CVV范围内是[-N,-F]->[-1,1]
                    z=-N时-(az+b)/z=-1 z=-F时-(az+b)/z=1
                    联立方程得出变换系数
                      a = (f+n)/(n-f) 
                      b = (2fn)/(n-f)
                    齐次坐标系数不变
            投影矩阵
                |cot(fov/2)/aspect 0                 0            0          ||x|
                |0                 cot(fov/2)        0            0          ||y|
                |0                 0                 (f+n)/(n-f)  (2fn)/(n-f)||z|
                |0                 0                 -1           0          ||1|
            裁剪
                投影后齐次坐标x满足-w<x'<w,y满足-w<y'<w,z满足-w<z'<w
            透视除法
                把坐标变换到了设备坐标系(范围是-1到1,-1到-1,-1到1之间)
                投影变换得到的齐次坐标除以w得出NDC坐标,w为0会发生除0异常,因此近裁面限制大于0,UNITY最小为0.01
                dx,metal等平台是(0,1)
                opengl/opengles是(-1,1)
            深度精度
                z-fighting问题
                因为从投影的z值变换不是线性的
                距离远裁面越近z-fighting问题越严重
                距离近裁面越近z-fighting问题越严重
                glPolygonOffset(factor,units)可以解决z-fighting闪烁问题
                    算法Offset=DZ*factor+r*units
                    (-1,-1)表示距离摄像机更近,用来渲染前景 
                    (1,1)表示距离摄像机更远,用来渲染背景
                开启深度测试
                    glEnable(GL_DEPTH_TEST);
                    glDepthMask(value);
                    glDepthFunc(GL_LESS|GL_GREATER|GL_LEQUAL);
                    glDisable(GL_DEPTH_TEST);
        正交投影 left right bottom top near far
            投影矩阵
                |1/(size*aspect) 0      0       0          ||x|
                |0               1/size 0       0          ||y|
                |0               0      2/(n-f) (f+n)/(n-f)||z|
                |0               0      0       1          ||1|
            裁剪
                投影后齐次坐标x满足-1<x'<1,y满足-1<y'<1,z满足-1<z'<1
                因为w分量为1,不需要透视除法
    视口变换
        NDC->屏幕
        宽度从[-1,1]变换到[x,w] 
        高度从[-1,1]变换到[y,h]
        深度值从[-1,1]变换到(n,f) nf在opengl里通过设置glDepthRange(n,f)来设定
        变换矩阵
            0.5w  0     0        0.5w+x
            0     0.5h  0        0.5h+y
            0     0     0.5(f-n) 0.5(f+n)
            0     0     0        1
射线
    起点是摄像机位置,经过的点是投影面上的点,检测这条射线与所有物体的多边形相交情况
    获取射线对象
        ScreenPointToRay
    获取碰撞结果
        使用物理引擎和射线对象检测碰撞结果 
        Physics.Raycast获取一个,Physics.RayCastAll获取多个
        Physics.OverlapSphere 球形碰撞,可用于检测周围物体