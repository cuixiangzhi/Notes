矩阵基础
    单位矩阵 
        n阶方阵对角线全1,其他元素全0
    逆矩阵
        AB相乘结果为单位矩阵,则AB互为逆矩阵
    转置矩阵
        A矩阵行列互换,主要用于在计算矩阵乘法时切换左乘右乘
    正交矩阵
        逆矩阵互为转置矩阵
    坐标系变换矩阵
        在目标坐标系下定义的三个正交基向量构成的矩阵*在这个坐标系下定义的向量
    变换顺序
        缩放->旋转->平移 T矩阵*R矩阵*S矩阵*列向量
    向量叉乘
        AxB = (AyBz-AzBy,AzBx-AxBz,AxBy-AyBx)
    齐次坐标
        N+1维向量表示N维向量,齐次坐标为(x,y,z,w) 
        w值不唯一 w=1为规格化坐标,此时(x,y,z)是普通坐标系下的坐标  w=0表示无穷远的点
        主要用于统一矩阵运算,便于变换的合成,便于硬件实现
    法线变换
        由于缩放变换可能不是等比缩放,因此MV矩阵变换之后法线可能不正确
        因此法线的MVP变换矩阵是 MV的逆转置矩阵把法线变换到视图空间,然后用从视图空间变换到CVV
    基变换
        相当于计算向量在目标坐标系各个轴上的投影长度,每个轴的结果都是点乘计算
        已知A坐标系下B坐标系的各个轴的表示,把B的坐标变换到A下,只需要B的各个轴组成行矩阵*列向量
    逆矩阵和转置矩阵
        如果一个矩阵只包含平移和旋转变换,那么它的逆矩阵等于它的转置矩阵
坐标系
    旋转正向
        从坐标轴的正向看向原点
            左手坐标系下,顺时针旋转为正向
            右手坐标系下,逆时针旋转为正向
    切线坐标系
        UV坐标是定义于切线坐标系下的
        U坐标方向是T轴,V坐标方向是B轴,法线是N轴
        切线是根据三个顶点的UV和三角形法线计算出来的
        每个三角形都有自己的切线空间,三角形的变换不会影响切线
    模型坐标系
        局部坐标系,是指模型本身的坐标系,以物体中心为原点,有自己的xyz轴
        默认放入世界坐标系的模型,局部坐标系和世界坐标系是重合的
        经过M矩阵变换转换到世界坐标系
    世界坐标系
        左手坐标系 x右y上z里
        右手坐标系 x右y上z内
        经过V矩阵变换转换到视图坐标系
    视图坐标系
        摄像机局部坐标系
        经过P矩阵转换到裁剪坐标系
    裁剪坐标系
        透视除法之前的坐标系,此时还保留有深度信息
        经过透视除法转换到NDC坐标系
    设备坐标系
        范围从-1到1,经过视口变换转换为视口坐标
        Z值范围根据平台不同有区别,DX和METAL范围是[0,1]
    屏幕坐标系
        unity中左下角为(0,0) 右上角为显示屏幕的(w,h)
        ngui中中心点为(0,0)
        gui左上角为(0,0)
        glut窗口左上角为(0,0)
    窗口坐标系
        屏幕坐标系下的一个子窗口,可以缩放移动关闭,与glut中的window概念一致 
        xy标记起始点,wh标记宽高 xywh均是整数,以屏幕分辨率为基准
    视口坐标系
        视口是窗口的一个区域,是真正的显示当前摄像机渲染结果的区域
        xy标记起始点,wh标记宽高 xywh均是0-1的数值,是窗口大小的比例
旋转变换
    欧拉角
        旋转都是从(0,0,0)开始按ZXY顺序旋转,跟当前状态没有任何关系
    轴角表达式
        旋转轴(vx,vy,vz) 旋转角度为0,不支持平滑插值
    四元数
        复数 
            z = a + bi a是实部,b是虚部,i是虚数单位,乘法是普通的乘法
        四元数
            q = w + xi + yj + zk
            q*= w - xi - yj - zk 共轭四元数是虚部取反
            q^= q*/|q|           逆四元数是共轭四元数除以模长,单位四元数共轭等于逆
            v'= qvq*             已知任意向量v,旋转轴u,旋转角度t, 四元数v=(0,v) 四元数q=(cos0.5t,usin0.5t)
            q = cos0 + xsin0i + ysin0j + zsin0k 绕旋转轴V=(X,Y,Z)旋转20角度
        欧拉角->四元数
            欧拉角首先拆分为3个坐标轴为基础的四元数,然后按照旋转顺序ZXY进行乘法化简,得出最终的四元数
            xyz = xyz * 0.5 * 2π/360 = xyz * 0.0087266462599716
            qx = cos(y)cos(x)sin(z) + sin(y)sin(x)cos(z)
            qy = cos(y)sin(x)cos(z) - sin(y)cos(x)sin(z)
            qz = sin(y)cos(x)cos(z) + cos(y)sin(x)sin(z)
            qw = cos(y)cos(x)cos(z) - sin(y)sin(x)sin(z)
        向量旋转(四元数*向量)
            Vector3 uv, uuv;
            Vector3 qvec(x, y, z);
            uv = qvec.crossProduct(v);
            uuv = qvec.crossProduct(uv);
            uv *= (2.0f * w);
            uuv *= 2.0f;
            return v + uv + uuv;
矩阵变换
    模型变换
        平移变换              
           |1 0 0 tx|   |1 0 0 -tx|  
           |0 1 0 ty|   |0 1 0 -ty|
           |0 0 1 tz|   |0 0 1 -tz|
           |0 0 0  1|   |0 0 0  1|    
        缩放变换
           |s 0 0 0|   |1/s 0   0    0|  
           |0 s 0 0|   |0   1/s 0    0|
           |0 0 s 0|   |0   0   1/s  0|
           |0 0 0 1|   |0   0   0    1|    
        旋转变换
            2D旋转
                旋转矩阵
                    |cos0 -sin0 0||x|
                    |sin0  cos0 0||y|
                    |0     0    1||1|
                绕任意点的旋转需要先平移到原点,T正 * R * T逆 * 列向量
            3D旋转
                绕某个轴逆时针旋转可以简化为在另外两个轴组成的平面上进行2D旋转,下述矩阵均在右手坐标系下计算
                    绕X轴旋转,x值不变 yoz平面 从x轴正向朝向原点看去逆时针旋转为正角度旋转,左手坐标系下z轴相反,对应正弦余弦变换符号即可
                        |1 0     0    0||x|
                        |0 cos0 -sin0 0||y|
                        |0 sin0  cos0 0||z|
                        |0 0     0    1||1|
                    绕y轴旋转,y值不变 zox平面 从y轴正向朝向原点看去逆时针旋转为正角度旋转,左手坐标系下z轴相反,对应正弦余弦变换符号即可
                        |1 cos0   sin0  0||x|
                        |0 1      0     0||y|
                        |0 -sin0  cos0  0||z|
                        |0 0      0     1||1|
                    绕z轴旋转,z值不变 xoy平面 从z轴正向朝向原点看去逆时针旋转为正角度旋转,左手坐标系下z轴相反,对应正弦余弦变换符号即可
                        |1 cos0 -sin0 0||x|
                        |0 sin0  cos0 0||y|
                        |0 0     1    0||z|
                        |0 0     0    1||1|
                    使用欧拉角旋转时矩阵的计算顺序影响最终结果
                任意轴旋转
                    首先对旋转轴构建一个正交矩阵,把点变换到世界坐标系
    视图变换    
        视图坐标系是右手坐标系,因此Z轴方向需要使用摄像机朝向的反方向,利用坐标系正交基变换
    投影变换
        投影变换把坐标变换到了裁剪坐标系(CVV)(-1,1) DX(0,1)
        透视投影 fov(视角) aspect(屏幕宽高比) n(近裁面到原点距离) f(远裁面到原点距离)
            投影坐标
                顶点坐标v=(x,y,z)
                投影坐标v'=(-nx/z,-ny/z,-(az+b)/z)
                X方向
                    映射到CVV范围内是从[-w/2,w/2]->[-1,1]
                    -nx/z的范围是[-w/2,w/2] w = h*aspect = 2n*tan(fov/2)*aspect
                    变换系数为 (-n/z)/(w/2) = cot(fov/2) / aspect / -z
                    齐次坐标系数为 cot(fov/2) / aspect
                Y方向
                    映射到CVV范围内是[-h/2,h/2]->[-1,1]
                    -ny/z的范围是[-h/2,h/2] h = 2n*tan(fov/2)
                    变换系数为 (-n/z)/(h/2)= cot(fov/2) / -z
                    齐次坐标系数为 cot(fov/2)
                Z方向
                    映射到CVV范围内是[-N,-F]->[-1,1] 或者 [N,F]->[0,1]
                    联立方程得出变换系数
                      a = (f+n)/(n-f)  或者 a = f/(f-n)
                      b = (2fn)/(n-f)       b = nf/(n-f)
                ZBuffer
                    OpenGL和DX的zbuffer数值范围都是(0,1),而且都是非线性的
                    把zbuffer的非线性映射到线性,需要用到DX的投影公式aZe(0,f)+b=Zb(因为DX的NDC范围是0到1,Zbuffer=Zndc)
                    根据投影矩阵的a和b可以计算出Ze0f=nf/(f-Zb*(f-n)) Ze01=Ze0f/f=1/(aZb+b)
                        解得a=1-f/n b=f/n 或者 a=-1+f/n b=1 (Zb为了提高远处的精度可能是反转的,因此要做1-Zb)
            投影矩阵
                |cot(fov/2)/aspect 0                 0            0          ||x|
                |0                 cot(fov/2)        0            0          ||y|
                |0                 0                 (f+n)/(n-f)  (2fn)/(n-f)||z|
                |0                 0                 -1           0          ||1|
            CVV裁剪
                投影后齐次坐标x满足-w<x'<w,y满足-w<y'<w,z满足-w<z'<w
            透视除法
                把坐标变换到了设备坐标系(范围是-1到1,-1到-1,-1到1之间)
                投影变换得到的齐次坐标除以w得出NDC坐标,w为0会发生除0异常,因此近裁面限制大于0,UNITY最小为0.01
                dx,metal等平台是(0,1) opengl/opengles是(-1,1)
            深度精度
                因为z值变换不是线性的,Zndc=a+b/Zcamera,反比例函数Zcamera从Near到Far,Zndc从0到1
                深度变化曲线是从1到-1,f到n,nf的距离越大,f处的精度越低
                glPolygonOffset(factor,units)可以解决z-fighting闪烁问题
                    (-1,-1)表示距离摄像机更近,用来渲染前景 
                    (1,1)表示距离摄像机更远,用来渲染背景
        正交投影 left right bottom top near far
            投影矩阵
                |1/(size*aspect) 0      0       0          ||x|
                |0               1/size 0       0          ||y|
                |0               0      2/(n-f) (f+n)/(n-f)||z|
                |0               0      0       1          ||1|
            裁剪
                投影后齐次坐标x满足-1<x'<1,y满足-1<y'<1,z满足-1<z'<1
                因为w分量为1,不需要透视除法
    视口变换
        NDC->屏幕
        宽度从[-1,1]变换到[x,w] 高度从[-1,1]变换到[y,h] 深度值从[-1,1]变换到(n,f) 
        nf在opengl里通过设置glDepthRange(n,f)来设定,一般是(0,1)
        变换矩阵(w,h是屏幕宽高)
            0.5w  0     0        0.5w
            0     0.5h  0        0.5h
            0     0     0.5      0.5
            0     0     0        1
        裁剪空间->视口空间(光栅化插值不会破坏齐次坐标连续性)
            裁剪坐标为(x,y,z,w) xyz范围都是(-w,w),w=-zeye或者zeye
            视口坐标为x'=0.5x+0.5 y'=0.5y+0.5 z'=0.5z+0.5 (x',y',z')范围是(0,w),深度图存储的是z'
            ComputeScreenPos用来计算齐次视口坐标,2x'-1可以计算出裁剪坐标
    线性插值
        三角形内部的像素是根据屏幕坐标插值得出来的
        xy由于平行于屏幕,因此线性插值是正确的
        z值投影之后变成了N,失去了意义,要保证z值线性插值正确,结果才是正确的
        xy投影之后的坐标与1/z是线性关系,因此z值是1/z的线性函数(az+b)/z