ShadowAcne
    阴影图分辨率不够,导致与光源方向角度很小时产生条纹状的自阴影现象
    shadow bias
        计算光源空间深度图时统一向光源朝向移动一点距离,减弱光源空间下倾斜物体的自阴影现象
        bias = max(factor * (1 - dot(normal,light)),constant) 微调factor和constant
    normal bias
        计算光源空间深度图时统一把模型沿法线方向稍微缩小,减弱角色阴影偏移脚底(悬空)的现象
ShadowMap
    LightSpaceShadowMap
        1.以实时灯光位置作为视点,渲染一张深度纹理
            生成过程: 
                顶点shader计算深度
                    o.pos = UnityObjectToClipPos(v.vertex);
                    o.depth = o.pos.zw
                像素shader记录深度(因为有差值)
                    float depth = o.depth.x / o.depth.y
                    fixed4 depth_color = EncodeFloatRGBA(depth)
                    这种方式已经过时,直接使用DepthFormat格式的Framebuffer即可
         2.接受阴影的物体从模型空间转换到灯光空间,和深度图作比较,大于深度图中的深度则为阴影
            计算过程
                顶点shader计算深度
                    objectToLightProj = mul(worldToLightProj,unity_ObjectToWorld);
                    o.proj = mul(objectToLightProj,v.vertex);
                    o.depth = o.proj.zw
                像素shader比较深度
                    fixed4 depth_texture_color = tex2Dproj(_LightDepthTexture,o.proj);
                    float depth_texture = DecodeFloatRGBA(depth_texture_color);
                    float depth_current = o.depth.x / o.depth.y - shadowBias
                    if(depth_texture < depth_current) 阴影
    CascadeShadowMap
        原理:如果使用相同的正交投影矩阵计算物体在平行光下的投影坐标,近处的物体会由于深度精度问题而产生很多锯齿
        优化:把摄像机的视椎体分成N个部分,每个部分分别根据梯形8个顶点得出平行光正交摄像机下的AABB包围盒作为平行光的正交摄像机范围
        计算:
            计算灯光摄像机的视椎体参数
                视锥SIZE取决于VIEW.AABB在LightSpace下的XY大小,视锥远近平面位置取决于SCENE.AABB在LightSpace下的Z值范围
                var sceneBound = CalculSceneBoundsInLightSpace()
                var viewBound = CalculViewBoundsInLightSpace()
                camera.localPosition = Vector3(viewBound.center.x,viewBound.center.y,0)
                camera.orthographicSize = math.max(viewBound.size.x * 0.5f,viewBound.size.y * 0.5f)
                camera.nearPlane = sceneBound.zmin
                camera.farPlane = sceneBound.zmax
            计算CSM级别划分和视锥参数

    ScreenSpaceShadowMap
        ZBuffer
            zbuffer=(az+b)/(z|-z)
            深度图记录的是非线性变换的zbuffer值,采样之后要使用Linear01Depth映射到[0,1]或者[n,f]
        1.首先在当前摄像机处创建相机渲染一张深度图
            生成结果是_CameraDepthTexture
        2.然后在灯光位置创建相机渲染一张深度图
            生成结果是_LightDepthTexture
        3.对屏幕进行一次后处理操作,输入两张深度图,输出_ShadowMapTexture
            顶点shader直接转存uv坐标
                o.uv = v.uv
            像素shader计算屏幕空间阴影图
                首先需要把当前像素点从屏幕坐标系变换到灯光坐标系
                屏幕坐标系->摄像机坐标系
                float3 vpos = computeCameraSpacePosFromDepth
                摄像机坐标系->世界坐标系
                float4 worldPos = mul(unity_CameraToWorld,vpos)
                世界坐标系->灯光坐标系
                float4 lightPos = mul(unity_WorldToLightProj,worldPos)
            生产结果是_ShadowMapTexture
        4.正常渲染物体
            像素shader使用屏幕坐标采样_ShadowMapTexture
Projector
    1.用一个摄像机在指定方向渲染指定层级的物体生成_ProjectTexture
        生成过程:
            把FrameBuffer清空为透明颜色
            顶点shader常规计算裁剪坐标
            像素shader直接返回不透明颜色,最终的贴图alpha大于0表示阴影
    2.被投影的物体渲染两次,第一次正常渲染,第二次使用指定材质球渲染
        计算过程:
            正片叠底混合 Blend DstColor Zero
            顶点shader计算当前顶点的投影纹理齐次坐标
                sproj = mul(_Projector,v.vertex);
            像素shader采样然后插值计算alpha进行混合
                shadow = tex2D(_ShadowTex,sproj.xy//sproj.w).a