bandwidth数据带宽
    开启遮挡剔除
        尽可能的把不需要渲染的物体裁剪掉,减少数据传输同时减少计算量
    使用LOD和GPUInstance
        远处的物体用低模和实例化渲染都可以减少数据量,降低shader计算量
    开启MIPMAP
        远处的物体使用更小的纹理,降低纹理带宽
shader计算复杂度
    使用向量运算
        GPU执行的都是向量运算,float和float4的计算耗时是一样的,尽量合并成向量去做计算和赋值
    减少分支语句
        GPU以wrap来执行shader指令,一个wrap包含N个thread,它们的指令完全相同并且同步执行,遇到分支之后会产生新的wrap
    降低变量精度
        精度越低越好,保证范围的情况下使用最低的精度
    减少采样次数
        访问周期:寄存器(1)->共享内存(1~32)->L1缓存(1~32)->L2缓存(32~64)->纹理/常量缓存(400~600)->全局内存
    降低分辨率
        降低屏幕分辨率可以减少需要计算的像素数,从而降低GPU计算量
overdraw重复绘制
    像素块
        GPU会以2x2的像素块为单位分配给一个core去执行,每个core包含4个thread,每个thread只负责一个像素
    减少AlphaTest和AlphaBlend
        这两个操作都在ZTest之后执行,开启之后无法进行Early-Z
    开启背面裁剪
        不开启两个面都会渲染
    控制粒子数量
        大量的小物体(粒子、植被、沙石、毛发等待)由于像素块的划分机制会造成严重的overdraw
tbdr优化
    FrameData拷贝
        尽量减少触发FrameData和FrameBuffer之间互相拷贝的操作