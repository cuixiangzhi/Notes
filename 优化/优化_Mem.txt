代码内存
    component_memory
        Animator
            FBX导入时Rig不要生成Avatar(除非需要动作混合),动画类型选择None
        Others
            避免在GameObject挂一些无意义的组件,会占用少许内存,有一定初始化和更新消耗
    code_memory
        泛型乱用,导致代码编译速度慢、代码占用
    delegate_memory
        闭包和匿名函数,最终都是一个class,每次只需都生成一个新对象
    coroutine_memory
        协程内的所有变量都会以class的成员变量形式存在直到协程执行结束
    native_memory
        UNITY底层按照类型(MemoryLabel)划分内存池,释放之后会及时返还给操作系统
    managed_memory
        UNITY底层采用的是不分代不紧缩的算法,释放的内存在一定条件下会返回给操作系统(连续6次没有被访问到)
    table_memory
        数据表需要自定义数据格式,支持分行读取,支持LRU缓存
资源内存
    shader_memory
        shader_feature
            只生成bundle内引用到keyword的变体
            使用#pragma shader_feature keyword来定义
            使用[Toggle(feature) ..]在材质上显示该选项
        multi_compile
            生成所有keyword对应的变体
            使用#pragma multi_compile keyword来定义(keyword最多256个,超过这个值会报错)
            使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
        variants
            宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载和编译时间并增加内存占用
            shader_variant_collection: shader变体集合(指定包含哪些shader和对应variant),可以用来在启动或空闲时预编译(执行wramup)
            i_preprocess_shaders: 打包后处理阶段,可以实现shader变体的剔除
            shader_variant_bundle: shader打包时默认只生成bundle内的材质使用到的变体
    mesh_memory
        MeshCompression
            使用压缩算法减少硬盘空间占用,不影响运行时数据,默认关闭,开启会影响下面两种压缩
        OptimizeMeshData
            打bundle时剔除shader没有使用到的顶点属性,可以减小包体
        VertexCompression
            降低顶点属性的精度(float->half),针对300顶点以上、未开启R/W的网格生效
        Read/Write Enabled
            开启该选项的纹理、网格会在内存中存在两份(显存+内存)
        DynamicBatching
            开启之后300顶点以下的网格会强制开启R/W
        StaticBatching
            TODO
        SkinnedMesh
            由于骨骼动画需要在CPU端每帧计算顶点位置,会强制开启R/W
        ParticleMesh
            粒子和骨骼动画类似,因为要做位置计算,会强制开启R/W
        MeshCollider
            添加了MeshCollider并且缩放带负数,会强制开启R/W
    texture_memory
        upload_buffer
            从内存中往显存上传的时候,会先放到一个缓冲区内,缓冲区满了才会上传
        read/write
            开启之后内存中会保留一份
        mipmap
            开启之后内存占用会增加30%,但是可以提高渲染效率(降低显存带宽、提高缓存命中率)
        streaming
            根据poolsize和sceneview情况动态加载/卸载纹理的mipmap,poolsize需要根据机器内存指定或者动态调整
    audio_memory
        dsp_buffer
            FMOD播放声音会先写入到一个BUFFER内,BUFFER填充满了才会播放,太大会导致声音延迟,太小CPU消耗上升
        speaker_mode
            FMOD使用双声道内存会占用两份,最好选用mono模式(默认是stereo)
        fmod_bank
            master.string.bank存储了所有event的路径信息,可以通过getStringInfo获取资源信息(event:* bank:* vca:* bus:*)
            name.bank文件是由metadata|sampledata|streamingdata三部分组成,loadBank时可以指定只加载metadata,sampledata自己控制加载
        audio_format
            音乐:Streaming+Vorbis 音效:DeCompressOnLoad+ADPCM 录音频率:8KHZ
        audio_cache
            2D:1 2D_ONE:1 3D:5 BG:1 CG:2
    video_memory
        video_format
            720P:低码率1Mbps,中码率2Mbps,高码率4Mbps 1080P:低码率2Mbps,中码率4Mbps,高码率8Mbps
            MP4格式:H264视频编码和AAC音频编码 WEBM格式:VP8视频编码和VORBIS音频编码
    animation_memory
        animation_cache&io
            游戏内角色会有很多休闲动作,需要支持动态加载和卸载,支持LRU缓存
        animation_frame
            动捕的关键帧几乎是满帧,需要简化(删除缩放曲线、简化直线帧)
    bundle_memory
        typetree
            为了做不同版本的类型兼容,开启之后会写入变量类型的信息
        lz4&lzma
            lz4分块解压,lzma是整体压缩,lz4占内存小,解压速度快
        size&count
            每个包多大,什么资源打一个,文件头占用内存是否远小于资源内存