代码内存
    table_memory
        数据表需要自定义数据格式,支持分行读取,支持LRU缓存
    gcalloc_memory
        closure_memory
            委托、协程、Lambda函数等最终都会生成一个class对象,传递函数给委托类型时会创建委托对象,每次开启协程都会创建协程对象
        array_memory
            调用某些API返回数组时有内存分配,例如GetComponents Mesh.vertices Physics.RaycastAll ParticleSystem.Start|Stop|Clear
        proto_memory
            协议的收发会分配很多小内存,序列化发送时最好直接写到缓冲区,反序列化尽量支持消息池
        boxing_memory
            params_memory
                禁止使用可变参数,重载多个函数来替代可变参数
            comparer_memory
                对值类型做Key相等比较时如果没有实现IEquatable接口,会在比较时进行装箱(默认使用ObjectEqualityComparer来获取HashCode并进行Equals比较,60BGC)
        string_memory
            统一日志接口,区分发布和调试接口,禁止使用..拼接日志
    component_memory
        减少没有意义的Actor、Component的创建,可以稍微降低内存和实例化开销
资源内存
    shader_memory
        shader_feature
            只生成bundle内引用到keyword的变体
            使用#pragma shader_feature keyword来定义
            使用[Toggle(feature) ..]在材质上显示该选项
        multi_compile
            生成所有keyword对应的变体
            使用#pragma multi_compile keyword来定义(keyword最多256个,超过这个值会报错)
            使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
        variants
            宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载和编译时间并增加内存占用
            shader_fallback:      关闭fallback可以减少变体数量(keyword变少)
            i_preprocess_shaders: 打包后处理阶段,可以实现shader变体的剔除
            shader_variant_collection: shader变体集合(指定包含哪些shader和对应variant),可以用来在启动或空闲时预编译(执行wramup)
    texture_memory
        upload_buffer
            从内存中往显存上传的时候,会先放到一个缓冲区内,缓冲区满了才会上传
        read/write
            开启之后内存中会保留一份
        mipmap
            开启之后内存占用会增加30%,但是可以提高渲染效率(降低显存带宽、提高缓存命中率)
        streaming
            根据poolsize和sceneview情况动态加载/卸载纹理的mipmap,poolsize需要根据机器内存指定或者动态调整
    mesh_memory
        MeshCompression
            使用压缩算法减少硬盘空间占用,不影响运行时数据,默认关闭,开启会影响下面两种压缩
        OptimizeMeshData
            打bundle时剔除shader没有使用到的顶点属性,可以减小包体
        VertexCompression
            降低顶点属性的精度(float->half),针对300顶点以上、未开启R/W的网格生效
        Read/Write Enabled
            开启该选项的纹理、网格会在内存中存在两份(显存+内存)
        DynamicBatching
            开启之后300顶点以下的网格会强制开启R/W
        StaticBatching
            开启之后引用同一份网格的对象变成多个实例(引用一个StaticMesh的不同部分)
        SkinnedMesh
            由于骨骼动画需要在CPU端每帧计算顶点位置,会强制开启R/W
        ParticleMesh
            粒子和骨骼动画类似,因为要做位置计算,会强制开启R/W
        MeshCollider
            添加了MeshCollider并且缩放带负数,会强制开启R/W
    animation_memory
        animation_cache&io
            游戏内角色会有很多休闲动作,需要支持动态加载和卸载,支持LRU缓存
        animation_frame
            动捕的关键帧几乎是满帧,需要简化(删除缩放曲线、简化直线帧)
    audio_memory
        dsp_buffer
            FMOD播放声音会先写入到一个BUFFER内,BUFFER填充满了才会播放,太大会导致声音延迟,太小CPU消耗上升
        speaker_mode
            FMOD使用双声道内存会占用两份,最好选用mono模式(默认是stereo)
        fmod_bank
            master.string.bank存储了所有event的路径信息,可以通过getStringInfo获取资源信息(event:* bank:* vca:* bus:*)
            name.bank文件是由metadata|sampledata|streamingdata三部分组成,loadBank时可以指定只加载metadata,sampledata自己控制加载
        audio_format
            音乐:Streaming+Vorbis 音效:DeCompressOnLoad+ADPCM 录音频率:8KHZ
        audio_cache
            2D:1 2D_ONE:1 3D:5 BG:1 CG:2
    video_memory
        video_format
            720P:低码率1Mbps,中码率2Mbps,高码率4Mbps 1080P:低码率2Mbps,中码率4Mbps,高码率8Mbps
            MP4格式:H264视频编码和AAC音频编码 WEBM格式:VP8视频编码和VORBIS音频编码
    bundle_memory
        typetree
            为了做不同版本的类型兼容,开启之后会写入变量类型的信息
        lz4&lzma
            lz4分块解压,lzma是整体压缩,lz4占内存小,解压速度快
        size&count
            每个包多大,什么资源打一个,文件头占用内存是否远小于资源内存