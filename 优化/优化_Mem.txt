shaderlab
    shader_feature
        定义的变体没有使用到不会被编译
        使用#pragma shader_feature 来定义
        使用[Toggle(feature) ..]在材质上显示该选项
    multi_compile
        定义的变体都会编译
        使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
        keyword最多256个,超过这个值会报错
    variants
        宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载时间并增加内存占用
    判断是否被使用:
        shader如果单独打包,此时shader不会编译生成任何变体
        shader和材质打包,shader会根据材质的keyword信息编译生成对应的变体
        实现IPreprocessShaders接口打包时剔除变体
    强制生成变体:
        1.把shader放在always include shaders
        2.把shader放在resources内
        3.增加多余的材质,定义对应的变体keyword
        4.5.0以后版本提供的shader_variant_collection,针对每个shader指定要使用哪些keyword,把collection放在preload或者和shader打包在一起
r/w_memory
    read/write enabled
        开启该选项的纹理、网格会在内存中存在两份(显存+内存)
    dynamic_batching
        开启之后300顶点以下的网格会强制开启R/W
mesh_memory
    MeshCompression
        使用压缩算法减少硬盘空间占用,默认关闭
    OptimizeMeshData
        打bundle时剔除shader没有使用到的顶点属性,可以减小包体
    VertexCompression
        降低顶点属性的精度,针对300顶点以上、未开启R/W的网格生效
component_memory
    Animator
        FBX导入时Rig不要生成Avatar(除非需要动作混合)
    Rigidbody
fmod_memory
    dsp_buffer
        FMOD播放声音会先写入到一个BUFFER内,BUFFER填充满了才会播放,太大会导致声音延迟,太小CPU消耗上升
    speaker_mode
        FMOD使用双声道内存会占用两份,最好选用MONO模式
code_memory
    泛型乱用,导致代码编译速度慢、代码占用
bundle_memory
    typetree
        为了做不同版本的类型兼容,开启之后会写入变量类型的信息
    lz4
        分块解压,lzma是整体压缩
    size&count
        每个包多大,什么资源打一个
        文件头也会占用内存,官方推荐一个AB包1M
resources
    DO NOT USE IT!
texture_memory
    upload_buffer
        从内存中往显存上传的时候,会先放到一个缓冲区内,缓冲区满了才会上传
    read/write
        开启之后内存中会保留一份
    mipmap
内存池
    Native内存池
        按照类型(MemoryLabel)划分内存池
        释放之后会及时返还给操作系统
        内存占用
            Scene Audio Code AssetBundle Texture
    VM内存池
        释放的内存在一定条件下会返回给操作系统(连续6次没有被访问到)
        不分代不压缩
        内存碎片化
            频繁分配回收小内存,然后申请大内存会导致内存不断上升
            先申请大块内存,然后对小内存做缓存池处理
        GC机制考量
            回收能力
            暂停时长
            碎片化
            额外消耗
            可扩展性
            可移植性
        内存占用
            闭包和匿名函数,最终都是一个class
            协程内的所有变量都会一直存在,以class的成员变量存在
            配置表占内存极大,要分模块甚至分行,并且要支持卸载
    UPR内存及性能分析工具