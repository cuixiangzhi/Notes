内存峰值
    PSS 500~700M
代码内存
    component_memory
        Animator
            FBX导入时Rig不要生成Avatar(除非需要动作混合),动画类型选择None
        Others
            避免在GameObject挂一些无意义的组件,会占用少许内存,有一定初始化和更新消耗
    code_memory
        泛型乱用,导致代码编译速度慢、代码占用
    delegate_memory
        闭包和匿名函数,最终都是一个class,每次只需都生成一个新对象
    coroutine_memory
        协程内的所有变量都会以class的成员变量形式存在直到协程执行结束
    native_memory
        UNITY底层按照类型(MemoryLabel)划分内存池,释放之后会及时返还给操作系统
    managed_memory
        UNITY底层采用的是不分代不紧缩的算法,释放的内存在一定条件下会返回给操作系统(连续6次没有被访问到)
        内存碎片化
            频繁分配回收小内存,然后申请大内存会导致内存不断上升
            先申请大块内存,然后对小内存做缓存池处理
    table_memory
        数据表会占用很大内存,要分模块甚至分行,并且要支持卸载
资源内存
    shader_memory
        shader_feature
            只生成bundle内引用到keyword的变体
            使用#pragma shader_feature keyword来定义
            使用[Toggle(feature) ..]在材质上显示该选项
        multi_compile
            生成所有keyword对应的变体
            使用#pragma multi_compile keyword来定义(keyword最多256个,超过这个值会报错)
            使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
        variants
            宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载和编译时间并增加内存占用
            shader_variant_collection: shader变体集合(指定包含哪些shader和对应variant),可以用来在启动或空闲时预编译(执行wramup)
            i_preprocess_shaders: 打包后处理阶段,可以实现shader变体的剔除
            shader_variant_bundle: shader打包时默认只生成bundle内的材质使用到的变体
    mesh_memory
        MeshCompression
            使用压缩算法减少硬盘空间占用,不影响运行时数据,默认关闭,开启会影响下面两种压缩
        OptimizeMeshData
            打bundle时剔除shader没有使用到的顶点属性,可以减小包体
        VertexCompression
            降低顶点属性的精度(float->half),针对300顶点以上、未开启R/W的网格生效
        Read/Write Enabled
            开启该选项的纹理、网格会在内存中存在两份(显存+内存)
        DynamicBatching
            开启之后300顶点以下的网格会强制开启R/W
        StaticBatching
            TODO
        SkinnedMesh
            由于骨骼动画需要在CPU端每帧计算顶点位置,会强制开启R/W
        ParticleMesh
            粒子和骨骼动画类似,因为要做位置计算,会强制开启R/W
        MeshCollider
            添加了MeshCollider并且缩放带负数,会强制开启R/W
    texture_memory
        upload_buffer
            从内存中往显存上传的时候,会先放到一个缓冲区内,缓冲区满了才会上传
        read/write
            开启之后内存中会保留一份
        mipmap
    audio_memory
        dsp_buffer
            FMOD播放声音会先写入到一个BUFFER内,BUFFER填充满了才会播放,太大会导致声音延迟,太小CPU消耗上升
        speaker_mode
            FMOD使用双声道内存会占用两份,最好选用mono模式(默认是stereo)
    animation_memory

    bundle_memory
        typetree
            为了做不同版本的类型兼容,开启之后会写入变量类型的信息
        lz4&lzma
            lz4分块解压,lzma是整体压缩,lz4占内存小,解压速度快
        size&count
            每个包多大,什么资源打一个,文件头占用内存是否远小于资源内存