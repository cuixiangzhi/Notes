代码内存
    component_memory
        Animator
            FBX导入时Rig不要生成Avatar(除非需要动作混合),动画类型选择None
        Others
            避免在GameObject挂一些无意义的组件,会占用少许内存,有一定初始化和更新消耗
    code_memory
        泛型乱用,导致代码编译速度慢、代码占用
    delegate_memory
        闭包和匿名函数,最终都是一个class,每次只需都生成一个新对象
    coroutine_memory
        协程内的所有变量都会以class的成员变量形式存在直到协程执行结束
    native_memory
        UNITY底层按照类型(MemoryLabel)划分内存池,释放之后会及时返还给操作系统
    managed_memory
        UNITY底层采用的是不分代不紧缩的算法,释放的内存在一定条件下会返回给操作系统(连续6次没有被访问到)
        内存碎片化
            频繁分配回收小内存,然后申请大内存会导致内存不断上升
            先申请大块内存,然后对小内存做缓存池处理
    table_memory
        数据表会占用很大内存,要分模块甚至分行,并且要支持卸载
资源内存
    shader_memory
        shader_feature
            定义的变体没有使用到不会被编译
            使用#pragma shader_feature 来定义
            使用[Toggle(feature) ..]在材质上显示该选项
        multi_compile
            定义的变体都会编译
            使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
            keyword最多256个,超过这个值会报错
        variants
            宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载时间并增加内存占用
        判断是否被使用:
            shader如果单独打包,此时shader不会编译生成任何变体
            shader和材质打包,shader会根据材质的keyword信息编译生成对应的变体
            实现IPreprocessShaders接口打包时剔除变体
        强制生成变体:
            1.把shader放在always include shaders
            2.把shader放在resources内
            3.增加多余的材质,定义对应的变体keyword
            4.5.0以后版本提供的shader_variant_collection,针对每个shader指定要使用哪些keyword,把collection和shader打包在一起
    mesh_memory
        MeshCompression
            使用压缩算法减少硬盘空间占用,不影响运行时数据,默认关闭,开启会影响下面两种压缩
        OptimizeMeshData
            打bundle时剔除shader没有使用到的顶点属性,可以减小包体
        VertexCompression
            降低顶点属性的精度(float->half),针对300顶点以上、未开启R/W的网格生效
        Read/Write Enabled
            开启该选项的纹理、网格会在内存中存在两份(显存+内存)
        DynamicBatching
            开启之后300顶点以下的网格会强制开启R/W
        StaticBatching
            TODO
        SkinnedMesh
            由于骨骼动画需要在CPU端每帧计算顶点位置,会强制开启R/W
        ParticleMesh
            粒子和骨骼动画类似,因为要做位置计算,会强制开启R/W
        MeshCollider
            添加了MeshCollider并且缩放带负数,会强制开启R/W
    texture_memory
        upload_buffer
            从内存中往显存上传的时候,会先放到一个缓冲区内,缓冲区满了才会上传
        read/write
            开启之后内存中会保留一份
        mipmap
    audio_memory
        dsp_buffer
            FMOD播放声音会先写入到一个BUFFER内,BUFFER填充满了才会播放,太大会导致声音延迟,太小CPU消耗上升
        speaker_mode
            FMOD使用双声道内存会占用两份,最好选用MONO模式
    animation_memory

    bundle_memory
        typetree
            为了做不同版本的类型兼容,开启之后会写入变量类型的信息
        lz4&lzma
            lz4分块解压,lzma是整体压缩,lz4占内存小,解压速度快
        size&count
            每个包多大,什么资源打一个,文件头占用内存是否远小于资源内存