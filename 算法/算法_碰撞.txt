碰撞检测算法
    精细的碰撞检测需要对物体建模,构建一个凸包围体,然后执行凸包围体之间的相交测试
    最精细的检测是最所有的面检查碰撞
    可以利用凸体的一些算法简化计算量
    利用AABB、八叉树、四叉树简化计算范围
凸包围体
    2D,andrew算法创建模型的凸包围体
    3D,quickhull算法创建模型的凸包围体
闵可夫斯基和
    两个点集A和B,C是minkosiki和,那么C=A+B,A中所有顶点加上B中所有顶点构成的集合
    顶点集A和B发生碰撞,那么C包含原点
    A和B的最短距离等价于C和原点的最短距离
Voronoi域
    每个面的N个顶点做沿法线方向的射线,射线围成的区域成为多面体的voronoi域
AABB
    矩形或者立方体包围盒,不带旋转的AABB碰撞检测可以快速判断
    a.minx > b.maxx || a.maxx < b.minx 
    a.miny > b.maxy || a.maxy < b.miny 
    a.minz > b.maxz || a.maxz < b.minz    
粗略测试阶段2D|3D
    已知场景边界bmin=(xmin,ymin,zmin)和bmax(xmax,ymax,zmax),得出场景bounds为(bmin,bmax)
    划分N叉树时要注意深度,深度影响平均搜索速度,深度为d时搜索时间为d * N
    细长物体可以使用二叉树,宽高比例接近1的可以使用四叉树或者八叉树
    N叉树用于快速查找目标对象(例如碰撞检测、视野内对象)
    二叉空间分割树构建
      递归划分,沿着长度较长的轴中间切一刀,划分成两部分,加入到当前结点的子结点内,继续划分子结点
      二叉树可以处理细长物体(即宽高比例太大),二叉树也可以用于处理3D细长物体
      适合处理静态对象或者静态场景
    四叉树构建
      忽略y方向变化,扩大为一个正方形,正方形划分四叉树比较容易
      递归划分,从根结点开始,划分为四个正方形,加入到当前结点的子结点内,继续划分子结点
    八叉树构建
      递归划分,从根结点开始,划分为四个立方体,加入到当前结点的子结点内,继续划分子结点
    上述构建过程可以是动态的,避免创建无效的结点
    对象添加
      从根结点开始,执行AABB碰撞检测,如果不在根结点内则不做后续处理
      深度优先遍历子结点,执行AABB碰撞检测,找到一个完全包含该物体的结点,修改该物体所属的结点ID
      当动态物体运动时,标记物体所属结点标记为旧数据,然后重新执行一次添加操作
精确测试阶段2D
    粒子,相交测试,粒子可以简化为一个点,判断点在多边形内还是外部即可
    点到线段的距离 圆和线段 圆和扇形
          先通过计算AB*AP求出夹角是锐角还是钝角,然后判断APcos∠PAB大小,也就是P点在线段AB上的投影点clamp到0,1
          然后根据向量加法PA + t*AB = P'P得出垂线段向量,t是0那么就是A点,t是1就是B点
          t = AP * AB / ab * ab
          t < 0,最近点是A,距离为PA
          t > 1,最近点为B,距离为PB
          d = len(PA + t*AB)

    点到矩形的距离 可用于判断圆和矩形是否相交
          计算V向量(矩形中心指向圆心P,并且x、y都取绝对值) U向量(V-H(矩形中心指向右上角顶点))(x、y取第一象限的值),计算U向量和圆半径大小
          vector2 v = abs(p-c);
          vector2 u = max(v-h,vector2.zero);
          return u * u <= r * r;

    点和三角形的关系
          求出质心坐标(u,v),三角形内的点满足(u >= 0) && (v >= 0) && (u + v < 1)  
          AP = u * AB + v * AC
          AP * AB = u * AB * AB + v * AC * AB
          AP * AC = u * AB * AC + v * AC * AC
          令 d00 = AB * AB; d11 = AC * AC; d20 = AP * AB; d21 = AP * AC; d01 = d10 = AB * AC;
          简化之后
          d20 = u * d00 + v * d01
          d21 = u * d01 + v * d11
          联立解得
          denom = d01 * d01 - d11 * d00
          u = (d11 * d02 - d01 * d12) / denom;
          v = (d01 * d02 - d00 * d12) / denom
          return (u >= 0) && (v >= 0) && (u + v < 1) 

    点和凸多边形的关系
          pnpoly算法,从该点沿坐标轴X向右或者向左发射射线,检测射线与凸多边形的交点个数,奇数个则相交
          点P(x,y,z) I是左点 J是右点 交点是Q
          点P必须在I和J之间,即 (Pz < Iz != Pz < Jz)
          求解两直线交点 (Qx - Jx) / (Pz - Jz) = (Ix - Jx) / (Iz - Jz)
          得出交点X坐标为 Qx = (Ix - Jx) / (Iz - Jz) * (Pz - Jz) + Jx
          判断是否相交 Qx <= Px  (只能向左或者向右发射射线,只判断同一方向)

    线段和线段的关系
          AB、CD,首先判断CD是否在AB两侧并且AB在CD两侧,并且共面
          normalize(cross(AB,AC)) == normalize(cross(AD,AB)) 
          normalize(cross(CD,CA)) == normalize(cross(CB,CD)) 

    凸多边形和凸多边形的关系
          分离轴算法,遍历所有的边,取边的垂线作为分离轴,计算两个凸多边形在轴上的投影范围
          投影有一个不相交则两个多边形是分离的
          已知两点A、B,分离轴经过原点,Pz / Px * (Bz - Az) / (Bx - Ax) = -1
          解出Px = Bz - Az; Pz = Ax - Bx
          那么分离轴为向量 n = (Bz - Az),0,-(Bx - Ax)
          计算投影范围,也就是计算原点指向边的顶点的向量在n上的投影
          计算出最大最小的点乘结果,比较
          分离轴算法是用一个平面分离2个凸体
    
    线段和凸多边形、圆和圆、圆和扇形、圆和矩形、圆和胶囊均可以通过上述测试组合得出
精确测试阶段3D
    包围球,相交测试,已知半径和中心点
            (a-b)^2 > (ar + br)^2           
    点到平面距离
          平面可以通过一点v和法向量n定义
          任意点p到平面的有符号距离d = |vp|cos0 = (vp*vn)/|vn|
          根据符号可以判断出点p在平面的哪一侧,d大于0在正面,d小于0在反面
          使用向量加法和距离d可以计算出投影点p'位置,判断p'在不在多边形(XZ平面)内,不在平面内则计算与边的最短距离
    点到AABB的距离
          首先计算点P与AABB的相对位置(点P在AABB的哪个voronoi域)
          计算P与AABB的最近点,只需要分别针对三个轴把P点坐标限制到aabb的min和max(在min和max直接的不作处理),得出的点在AABB上,就是最近的点
    点到OBB的距离
          首先把点P的坐标转换为相对于OBB的坐标,此时OBB就成了AABB,然后在计算点到AABB的距离
    点到多面体的距离
          首先计算点与每个面的关系以及点到平面的距离,最后得出整体距离(在内部或者有最小距离的面)
    多面体与多面体
          采用分离轴算法,针对每个平面做检测,看这个平面是否可以把两个凸体分开
    线段与平面的距离(射线会设置长度)
          首先计算出线段端点在面上的投影点和投影距离以及点和平面的位置关系
          然后利用法线向量和线段向量点乘求出夹角,再根据距离和向量加法求出交点
          得出交点之后求点与平面的关系
遮挡剔除
    当一个物体被其它物体挡住而不在摄像机可视范围内时不对其进行渲染,默认情况下这种计算是不开启的
    在渲染遮挡很多的情况时如果不做剔除会产生大量的overdraw(同一像素点被重复绘制多次)
    实现方式
      1.二叉空间分割树(BSP)
        计算出整个场景AABB,然后沿着最长的轴对物体排序,分成两部分,每个部分计算出自己的AABB,递归计算分割后的两部分
        通过计算视椎体所在AABB,能够快速查找出BSP内可见的物体列表
        无法解决视椎体内部存在很多遮挡的情况,仍然会产生大量overdraw(例如FPS游戏的带门的房子)
      2.Portal技术
        一个region就是一个封闭的空间,region与region之间通过portal(门窗)连接
        如果玩家处于一个region中,只能看到region内的物体和通过portal与之相连region内的物体
      3.EarlyZ技术
        提前执行深度测试,减少OverDraw计算
        不透明物体从近到远进行渲染,因为近处的物体一定会遮挡远处的物体
        天空盒在两者之间渲染
        半透明物体从远到近进行渲染,因为半透的物体需要执行混合操作
视椎体剔除
    不渲染视椎体外的物体,通过MVP变换能够得出三角面是不是在视椎体内
    