碰撞检测算法
	精细的碰撞检测需要对物体建模,构建一个凸包围体,然后执行凸包围体之间的相交测试
	最精细的检测是最所有的面检查碰撞
	可以利用凸体的一些算法简化计算量
	利用AABB、八叉树、四叉树简化计算范围
凸包围体
	2D,andrew算法创建模型的凸包围体
	3D,quickhull算法创建模型的凸包围体
闵可夫斯基和
	两个点集A和B,C是minkosiki和,那么C=A+B,A中所有顶点加上B中所有顶点构成的集合
	顶点集A和B发生碰撞,那么C包含原点
	A和B的最短距离等价于C和原点的最短距离
Voronoi域
	每个面的N个顶点做沿法线方向的射线,射线围成的区域成为多面体的voronoi域
AABB
	矩形或者立方体包围盒,不带旋转的AABB碰撞检测可以快速判断
	a.minx > b.maxx || a.maxx < b.minx 
	a.miny > b.maxy || a.maxy < b.miny 
	a.minz > b.maxz || a.maxz < b.minz    
粗略测试阶段2D|3D
	已知场景边界bmin=(xmin,ymin,zmin)和bmax(xmax,ymax,zmax),得出场景bounds为(bmin,bmax)
	划分N叉树时要注意深度,深度影响平均搜索速度,深度为d时搜索时间为d * N
	细长物体可以使用二叉树,宽高比例接近1的可以使用四叉树或者八叉树
	N叉树用于快速查找目标对象(例如碰撞检测、视野内对象)
	二叉空间分割树构建
		递归划分,沿着长度较长的轴中间切一刀,划分成两部分,加入到当前结点的子结点内,继续划分子结点
		二叉树可以处理细长物体(即宽高比例太大),二叉树也可以用于处理3D细长物体
		适合处理静态对象或者静态场景
	四叉树构建
		忽略y方向变化,扩大为一个正方形,正方形划分四叉树比较容易
		递归划分,从根结点开始,划分为四个正方形,加入到当前结点的子结点内,继续划分子结点
	八叉树构建
		递归划分,从根结点开始,划分为四个立方体,加入到当前结点的子结点内,继续划分子结点
	上述构建过程可以是动态的,避免创建无效的结点
	对象添加
		从根结点开始,执行AABB碰撞检测,如果不在根结点内则不做后续处理
		深度优先遍历子结点,执行AABB碰撞检测,找到一个完全包含该物体的结点,修改该物体所属的结点ID
		当动态物体运动时,标记物体所属结点标记为旧数据,然后重新执行一次添加操作
精确测试阶段2D
	粒子相交测试
		粒子可以简化为一个点,判断点在多边形内还是外部即可
	点到线段的距离 圆和线段 圆和扇形
		先通过计算AB*AP求出夹角是锐角还是钝角,然后判断APcos∠PAB大小,也就是P点在线段AB上的投影点clamp到0,1
		然后根据向量加法PA + t*AB = P'P得出垂线段向量,t是0那么就是A点,t是1就是B点
		t = AP * AB / AB * AB
		t < 0,最近点是A,距离为PA
		t > 1,最近点为B,距离为PB
		d = len(PA + t*AB)
	点到矩形的距离 可用于判断圆和矩形是否相交
		V向量(矩形中心指向圆心P,并且x、y都取绝对值,保证P点在右上角) 
		H向量(矩形中心指向右上角顶点)
		U向量(右上角指向圆心P,x、y都大于等于0)
		vector2 v = abs(p-c);
		vector2 u = max(v-h,vector2.zero);
		return u * u <= r * r;
	点和三角形的关系
		求出质心坐标(u,v),三角形内的点满足(u >= 0) && (v >= 0) && (u + v < 1)  
		AP = u * AB + v * AC
		AP * AB = u * AB * AB + v * AC * AB
		AP * AC = u * AB * AC + v * AC * AC
		简化代码
			d20 = AP * AB; d00 = AB * AB; d01 = AB * AC; 
			d21 = AP * AC; d10 = AB * AC; d11 = AC * AC;   
			d20 = u * d00 + v * d01
			d21 = u * d10 + v * d11
		联立解得
		denom = d01 * d10 - d00 * d11
		u = (d20 * d11 - d01 * d21) / denom;
		v = (d20 * d10 - d00 * d21) / denom
		return (u >= 0) && (v >= 0) && (u + v < 1) 
	点和凸多边形的关系
		pnpoly算法,从该点沿坐标轴X向右或者向左发射射线,检测射线与凸多边形的交点个数,奇数个则相交
		点P(x,y,z) I是左点 J是右点 交点是Q
		点P必须在I和J之间,即 (Pz < Iz != Pz < Jz)
		求解两直线交点 (Qx - Jx) / (Pz - Jz) = (Ix - Jx) / (Iz - Jz)
		得出交点X坐标为 Qx = (Ix - Jx) / (Iz - Jz) * (Pz - Jz) + Jx
		判断是否相交 Qx <= Px  (只能向左或者向右发射射线,只判断同一方向)
	圆和扇形
	圆和胶囊
	线段和线段的关系
		AB、CD,首先判断CD是否在AB两侧并且AB在CD两侧,并且共面
		normalize(cross(AB,AC)) == normalize(cross(AD,AB)) 
		normalize(cross(CD,CA)) == normalize(cross(CB,CD)) 
	凸多边形和凸多边形的关系
		分离轴算法,遍历所有的边,取边的垂线作为分离轴,计算两个凸多边形在轴上的投影范围,投影有一个不相交则两个多边形是分离的
		已知两点A、B,分离轴经过原点,向量AB和OP互相垂直(斜率相乘为1),那么分离轴为向量 n = (ABz,0,-ABx)
		计算投影范围,也就是计算原点指向边的顶点的向量在n上的投影(可以直接通过点乘计算)
		
精确测试阶段3D
	包围球
		(a-b)^2 > (ar + br)^2           
	点到平面距离
		平面可以通过一点v和法向量n定义
		任意点p到平面的有符号距离d = |vp|cos0 = (vp*vn)/|vn|
		根据符号可以判断出点p在平面的哪一侧,d大于0在正面,d小于0在反面
		使用向量加法和距离d可以计算出投影点p'位置,判断p'在不在多边形(XZ平面)内,不在平面内则计算与边的最短距离
		d = |N * v + D| / |N|
	点到AABB的距离
		针对三个轴把P点坐标限制到aabb的min和max(在min和max之间的不处理),得出的点在AABB上,就是最近的点
	射线与三角形的位置关系
		首先计算射线与三角形所在平面的交点坐标
			射线方程为 P = O + t * Ray
			平面方程为 n * P + D = 0
			联立方程可得 t = -(D + n * O)/(n * Ray) t小于0表示平面在射线背后
		然后计算交点的质心坐标
	射线和AABB的位置关系
		已知射线起点为O 方向为L 平面法线为N 平面交点为P OP=O+t*L
		计算射线与XYZ三个方向的平面的交点比例(tx1,tx2) (ty1,ty2) (tz1,tz2)
		如果三组范围值有交叉,则相交
遮挡剔除
	当一个物体被其它物体挡住而不在摄像机可视范围内时不对其进行渲染,默认情况下这种计算是不开启的
	在渲染遮挡很多的情况时如果不做剔除会产生大量的overdraw(同一像素点被重复绘制多次)
	实现方式
		1.二叉空间分割树(BSP)
			计算出整个场景AABB,然后沿着最长的轴对物体排序,分成两部分,每个部分计算出自己的AABB,递归计算分割后的两部分
			通过计算视椎体所在AABB,能够快速查找出BSP内可见的物体列表
			无法解决视椎体内部存在很多遮挡的情况,仍然会产生大量overdraw(例如FPS游戏的带门的房子)
		2.Portal技术
			一个region就是一个封闭的空间,region与region之间通过portal(门窗)连接
			如果玩家处于一个region中,只能看到region内的物体和通过portal与之相连region内的物体
		3.EarlyZ技术
			提前执行深度测试,减少OverDraw计算
			不透明物体从近到远进行渲染,因为近处的物体一定会遮挡远处的物体
			天空盒在两者之间渲染,可以减少overdraw,因为天空盒是一个位于远平面的面片
			半透明物体从远到近进行渲染,因为半透的物体需要执行混合操作