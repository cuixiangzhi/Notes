日期月份
	Monday Tuesday Wednesday Thursday Friday Saturday SunDay
	January February March April May June July August Spetember October November December

基础知识
	数值存储
		计算机只有加法运算器,计算机存储补码,运算器补码运算
		正数补码与原码一致 负数补码符号位不变,其余位取反加1
		N位有符号整数范围是1000..0->0111..1
	SSE指令
		支持SSE的CPU有8个128位寄存器,每个可以存储4个浮点类型数据
		支持SSE的CPU提供了一个指令集,可以把数据加载到这些寄存器以及对寄存器的数据执行逻辑运算
		在一个指令周期内可以同时进行多次相同的运算,减少循环次数
	字节对齐
		硬件支持
			不同的硬件对存储空间的处理不同,某些平台对特定类型的数据只能从特定地址开始存取,而不允许任意存放,有时会触发异常
		存取效率
			CPU是按照chunk来读取内存的,chunk大小可以是2字节、4字节、8字节等,chunk称为内存访问粒度
			CPU每次都是从chunk对齐地址处读取内存数据,如果一个数据不是对齐的,而是分散在不同的chunk上,那么就会增加访问次数
			CPU访问内存的时间:
				总线周期,一个总线周期由几个时钟周期组成;
				指令周期:执行一条指令的时间
				访问次数增加会增加访问数据消耗的总线周期时间
		对齐规则
			根据编译器的不同而不同
			自身对齐:以变量大小字节数对齐
			结构对齐:成员最大字节大小对齐
			指定对齐:#pragma pack(n)
			有效值:  min{自身对齐,指定对齐}
	变量类型
		int uint 32位
		short ushort 16位
		float double 
			表示形式	
				IEEE754编码方式 符号位(1) + 指数位(8|11) + 尾数(23|52) 指数=E-127|1024 符号位*(1.M)*2^E
			指数状态
				指数位全0且尾数全0,表示0
				指数位全1且尾数全0,表示INFINITY(无穷大)
				指数位全1且尾数非0,表示NAN(非数值)
			取值范围
				指数0和255被占用,因此指数范围是[-126,127]|[-1022,1023]
			有效位数
				单精度32位 误差为2^(e-23)
				双精度64位 误差为2^(e-52)
				lua采用双精度浮点数
				注意点
					有效位数并不是指前6位数字是有效的,而是指真实值和存储值的差与原值的比值在误差范围之内
					例如
						123456789存储为123456792,误差为3(小于2^(26-23)=8)
						1.1存储结果为1.10000002,误差为0.00000002(小于2^(-23)=0.0000001)
			定点数
				Sx.y(x为整数位数,y为小数位数),定点数会精确存储小数的每一位,误差在1/2^y以内
		string char uchar 
			 	字符数组和字符 
			 	char*最后是一个\0字符  
			 	C# char代表一个字符或者一个中文符号,长度不固定 
			 	lua和C++一样 字符集分为ASCII、GBK、Unicode等等  UTF-8是一种UNICODE编号的编码方式 GBK是GBK字符集编号的编码方式
				UTF-8不定字节编码以字节数开头,0xxxxxxx 表示一个字节  110xxxxx表示2个字节,后续字节以10开头  最多会有6个字节
		auto decltype typeid
			auto可以根据变量初始值的类型自动为此变量选择合适的类型,可以简化代码,不适合指针之类的语法记忆
			decltype用来查询表达式的返回值类型,不会计算表达式
	函数栈帧
		函数调用约定
			cdecl    参数从右至左入栈,调用参数之后生成add esp指令清理函数参数栈
			stdcall  参数从右至左入栈,被调用函数最终生成ret ?指令清理函数参数栈
			fastcall 参数从右至左入栈,被调用函数最终生成ret ?指令清理函数参数栈,不大于4个字节的参数存入寄存器ECX EDX
			thiscall this指针存储在ECX寄存器内
		函数名字编译
			_stdcall  C语言编译后为_funcname@nnumber C++编译后为?funcname@YG******@Z
			_cdecl    C语言编译后为_funcname         C++编译后为?funcname@YA******@Z
			_fastcall C语言编译后为@funcname@nnumber C++编译后为?funcname@YI******@Z
		函数栈帧指针
			ebp指向栈底,esp指向栈顶,栈指针从高地址向低地址移动
		函数调用和返回指令
			函数调用开始
				push param
				call func     call指令会保存返回地址(下一条指令地址),ret会返回到该地址继续执行
				调用约定
				add esp ?     cdecl调用约定会生成该指令
			函数代码开始
				保护现场
				push ebp      ebp指向调用函数栈底(调用函数的栈帧起始点)
				move ebp esp  esp指向当前函数栈底(被调函数的栈帧起始点)
				执行逻辑
				func code     临时变量、操作指令等等
				恢复现场
				move esp ebp  esp恢复为调用函数栈顶(esp指向调用函数栈帧的栈顶)
				pop ebp       ebp恢复为调用函数栈底(ebp指向调用函数栈帧的栈底)
				调用约定
				ret ?         stdcall调用约定会生成该指令
	多线程
		RingBuffer无锁环形缓冲区,适用于命令队列
		atomic标记,原子类型,加减操作是原子操作,不可再分 例如atomic<int>
	编译执行
		C++  GCC(LINUX) CL(WINDOWS) MINGW(WINDOWS)  
		JIT 即时编译,在运行时将频繁执行的方法编译成本地机器代码,需要可执行内存支持
		AOT 提前编译,运行前编译
	脚本语言 
		https://www.cnblogs.com/murongxiaopifu/p/4557365.html
	逆波兰式  
		后缀表达式,方便堆栈操作实现任意复杂度的表达式,一次扫描即可得出结果,遇到操作数压栈,遇到运算符弹出操作数并运算
		波兰式即前缀表达式,对应于二叉树的前序遍历结果,逆波兰式对应于后序遍历结果

汇编语言
	寄存器分类
		R0-R10 通用数据
		IP-R11 函数栈帧
		FP-R12 暂存数据
		SP-R13 栈顶指针
		LR-R14 返回地址
		PC-R15 指令指针
		CPSR   程序状态
	常见操作指令
		MOV A B 赋值指令,把B值赋给A
		CMP A B 比较指令
		JNE     跳转指令,条件跳转
		JMP     跳转指令,无条件跳转
		PUSH    压栈指令
		POP     出栈指令
		CALL PC 调用指令
		RET     返回指令
	SSE操作指令
		加载数据 _mm_load_si128
		存储数据 _mm_store_si128
		逻辑运算 __mm_adds_* _mm_or_* __mm_and_* __mm_subs_* __mm_cmp_*

C/C++
	关键字
		指针	
			它也是个变量,它的值是对象的地址,使用&运算符获取对象  p->等价于(&p).
			指针和引用变量赋值时必须匹配类型
		引用	
			变量换了个名字,没有内存分配,它和它引用的变量用的是一份内存
			引用必须在声明时初始化
		const
			顶层const：指针本身是个常量
			底层const：指针所指的对象是个常量
			const函数: 不可以修改类成员变量
			const参数: 不可以参数内容,const参数可以接收任意参数,非const只能接收非const类型参数
			const返回: 不可以修改返回值的内容
		static
			静态全局常量(文件内有效) 静态局部变量(作用域内有效)
		extern 
			外部变量
		#define 
			宏定义 ##宏拼接 ##用于拼接变量 #宏替换
		typedef 
			类型组合定义
		sizeof
			编译期有效,不能在运行时判断数据长度
		new&delete
			new object()  调用operator new函数分配内存,然后调用object的构造函数
			delete ptr    调用ptr所指向的对象的析构函数,然后调用operator delete函数释放内存
			operator new  内存分配函数void* operator new(size_t size)
			placement new 在指定内存块上构造对象 new (buffer) object()
	类型转换 
		static_cast 基本类型之间相互转换,可替代隐式转换
					类层次转换,父类到子类没有类型检查
		const_cast 只能改变底层const,也就是指针所指向的对象的const
		dynamic_cast 用于指针和引用的类层次转换,向下转换有类型检查,不一致结果为NULL
		reinterpret_cast 用于将二进制位解释为另一种类型
		operator T() 类型转换运算符,前面添加explicit后禁止隐式转换
	函数
		参数传递
			引用&值参数传递 
		左值参数传递
			直接在调用函数时构造一个对象传递,会发生两次构造
		右值参数传递
			传递构造出来的对象,避免二次构造
		函数指针  
			指针指向一个函数,可以直接P()调用
			定义一个函数,返回函数指针 int (*f())()
	类&继承
		private public protected friend class 
		virtual vptr 重载 覆盖 vtable virtual=0 
		虚表&虚表指针&虚继承&虚析构函数
			虚表: 每个带有虚函数的类都有一个静态的虚表
			虚表指针: 每个带有虚函数的类对象都有一个虚表指针,在构造函数内初始化
			虚析构函数: 声明了虚函数的基类必须实现虚析构函数,确保正确析构
			虚继承: 保证基类只有一份实例virtual-base-class
			注意点: 基类构造函数不能调用虚函数 子类必须实现虚基类的构造
		多态性
			编译时多态性,模板,重载
			运行时多态性,虚函数重写
		类初始化
		  	虚表指针->初始化列表->构造函数体
		内存布局
			类对象
				虚表指针(每个基类部分都有一个,构造的时候会经过多次初始化,直到子类对象)
				虚基类指针(虚继承才会有,每个虚基类都有一个,存储基类地址偏移)
				基类成员
				子类成员
				基类成员(多继承,虚继承时重复基类成员在最后面)
			虚函数表(多继承时有多个)
				基类虚函数(会被子类相同的虚函数覆盖)
				子类虚函数(只存在于第一个基类虚表)
		对象创建
			拷贝构造函数&赋值运算符重载 避免指针所指内存被共享
			把析构函数设置为私有,可以禁止在栈上创建对象,添加自定义函数删除对象
	模板&泛型
		模板定义	
			template<class T> return_type function_name(arg_type) {}
		模板特化
			template<> return_type function_name(special_arg_type) {}
		函数类型
			function<return_type (arg_type)>
			自定义函数类型模板(声明一个重载了()运算符的模板类)
			template<type_name T>
			class function<return_type (arg_type)> { return_type operator()(arg_type) }
			参数重新排列
			bind(func,placeorders::_1,_2,var);
		lambda  
			[捕捉列表](参数列表){函数体} =值捕捉 &引用
	常用基础函数
			   __LINE__ __FUNCTION__ __FILE__
		stddef NULL定义
		assert assert(ptr)
		ctype  isupper islower isdigit isalpha toupper tolower
		limit  最值宏定义
		math   常用数学函数
		signal 进程信号处理,signal函数用于注册信号处理函数,常见信号有
				SIGILL 非法指令 SIGINT 输入CTRL+D SIGABRT 终止 SIGCHLD 子进程异常停止 SIGFPE 除0异常 SIGKILL 杀死进程 SIGSEGV 非法内存访问 SIGSYS 非法系统调用
		stdlib 内存分配 malloc free 数值与字符串转换 atoi itoa 随机数 srand(seed) rand 系统操作 system exit abort 环境变量 getenv putenv
		stdarg 不定长参数  __VA_ARGS__ va_list ap; va_start(ap,format); char buffer[512]; len = vsprintf(buffer,format,ap); va_end(ap);
		string 字符串处理 strcat(dst,src) strcpy(dst,src) strstr(src,content) strlen(src) strcmp(src,dst) c_str
		ctime  低精度时间 time_t time(NULL)秒级系统时间 clock_t clock()毫秒级运行时间 tm localtime(time_t t)具体日期 
		chrono 高精度时间 steady_clock::now精度为100ns high_resolution_clock::now()
		stdio  C文件读写 fopen("path","wrab+") fclose(fp) fread(buffer,size,count,fp) fseek(fp,offset,seek_cur) ftell(fp)
						r:只读取ASCII可显示字符,遇到不可显示字符时读取结束
						open和write属于系统调用,低级IO无内存缓冲,不同操作系统不一样
		fstream C++文件读写 
		 			f("",ios::in|ios::out|ios:binary) f.close() eof()文件结尾
				   	tellg() tellp() 用于获取当前文件读取或者写入的位置
				   	seekg(offset,ios::cur) seekp() 用于移动读写指针到指定位置 ios::beg ios::cur ios::end
				   	read(buffer,size) write(buffer,size) 字节数组读写
		sstream 字符串读写 istringstream istr(string) istr.clear() istr.c_str() istr >> "string value"
		stl		vector 插入元素push_back insert 删除元素erase clear 
				list   插入元素push_back push_front insert 访问元素front back 删除元素erase pop_front pop_back
				stack  插入元素push 删除元素pop 访问元素top
				map&multimap  构造元素make_pair(key,value) 添加元素insert 删除元素erase 
		algorithm 查找(find、find_if) 删除 remove remove_if 赋值 fill fill_n 替换 replace replace_if 排序 sort 去重 unique
		iterator  迭代器 ::iterator iter = ww.begin() ww.end() cbegin cend rbegin rend
		dll		__declspec(dllexport) __stdcall __cdecl
				头文件 dlfcn.h unix可用 mac/windows需要别的API,编译时-ldl -rdynamic
				void* dlptr = dlopen("dlname",RTLD_NOW) 
				void* funcptr = dlsym(dlptr,"funcname")
				int ret = dlclose(dlptr)
		goto 	函数内跳转
		jmp     非局部跳转
				setjmp(jmp_buf env) 设置跳转点,保存函数上下文 直接调用返回0,跳转调用返回longjmp第二个参数
				longjmp(jmp_buf env,int ret) 调到跳转点,恢复函数上下文
	C++编程规范
		对象相关
			1.类的设计
				遵循设计模式原则:接口简单清晰易用
			2.类的实现
				构造与析构:带指针或者资源的类必须重载拷贝构造函数、赋值运算符,没特殊需求编译器默认生成的就可以
				头文件包含:使用前置声明代替INCLUDE,删除没意义的引用,降低文件依赖关系,加快编译速度
				虚函数:构造和析构过程中不要调用虚函数
			3.类的继承
				组合模式
				接口继承
				实现继承
				虚继承
		语言特性
			1.使用const代替#define 
				有类型检查并且const常量会被编译到机器指令
			2.资源管理
				以对象的形式进行资源管理,依靠构造和析构函数来处理资源的初始化和释放
				智能指针不能用于数组,因为析构调用的是delete而不是delete[]
	C++11特性
		构造函数
			删除函数:声明为private或者使用delete关键字 
			强制生成:使用default关键字
			嵌套调用:构造函数可以互相调用,不用再通过额外的函数来提取公共代码
		成员变量
			默认值:声明时可以直接添加默认值,赋值操作会在构造函数之前执行
		成员函数
			显示重载:添加override关键字编译器检查函数签名是否和基类虚函数一致
			禁止重载:添加final关键字禁止虚函数被子类重写
		枚举类型
			C++默认声明的枚举是全局的容易命名冲突,添加class关键字生成强类型枚举
		空指针
			NULL关键字是个值为0的int,在参数为int和ptr的时候产生歧义,用nullptr代替
		类型推断
			auto关键字代替模板类型简化代码(注意不要滥用,用多了会降低代码可读性)
		初始化列表
			以{}作为参数调用类的构造函数,参数类型为std::initializer_list<T>&

C#   
	.NET规范
		类似于OpenGL规范,.NET规范定义了实现这种技术需要的API集合
		CIL CLR CLI FCL等组成,CLR是运行时,CIL是中间语言,FCL是基础类库
		.NET2.0支持最常用的类库
		.NET3.5支持System.Linq
	.NET实现
		.NET FRAMEWORK是windows平台的.NET实现
		MONO是跨平台的.NET实现 mono2.0/.net2.0/3.5 mono2.10/.net4.0 mono3.4/.net4.5 mono4.4/.net4.6
  	反射
		特性,继承自System.Attribute的类,放在类上面通过构造函数初始化,可以使用GetType().GetCustomAttributes(类型,继承)获取所有特性
		Reflection 反射程序集包含 Type 类型管理 Assembly 程序集管理
  	DLL
		C++使用__cdecl __declspec(dllexport)导出API
		C#使用DllImport(dllName,EntryPoint,CharSet,CallVersion) static extern调用API
		int float bool uint long直接对应
	  	string对应char* 
	  	byte[]对应unsigned char*,传递时需要使用Marshal.Copy用于在托管与非托管之间转换内存 Marshal.Copy(src, start, dst, len);  Marshal.Copy(src, dst, start, len);
	  	function pointer对应 delegate MonoPInvokeCallback(typeof(DelegateName))
      	StructLayout(LayoutKind.Sequential),RequiredByNativeCode
		[MethodImpl(MethodImplOptions.InternalCall), WrapperlessIcall] 标记该方法在C++内实现		  
		C++使用mono运行C# DLL,需要mono提供的库和头文件,注意c# dll需要使用 mono命令来生成, msc *.cs -t:library
	ref&out
		参数传递默认为值传递(值类型复制一份,引用类型复制引用)
		引用传递传递地址,ref&out不会进行装箱操作

python 
	函数定义
		def name(params):
	判断是否是主动执行
		__name__ == "__main__": 
	设置文件编码
		#coding:utf-8 
		import sys
		reload(sys)
		sys.setdefaultencoding("utf-8")
	当前脚本执行路径
		import os
		os.path.abspath(sys.path[0])
	参数
		sys.argv数组
	数组  append   
	循环  for var in 数组或者range(1,n):
	文件操作  file = open(path,"wb")  file.write() file.close() file.readline file.readlines file.seek(cur,off) file.tell
	目录操作 是否为目录 os.path.isdir() 
			目录列表 os.listdir()
			删除空目录 os.rmdir()
			路径是否存在 os.path.exists()
			分解为文件名和路径 os.path.split()
			删除目录 shutil.rmtree()
						shutil copy()文件夹
						shutil copyfile 文件
						shutil move 移动
						shutil remove 删除文件
	堆栈   traceback.print_exc()
	输入  rawinput()
	字符串  string[0:-3]  
			string.split() 
			字符串拼接 string.join(array)  "%s" % varname  a + b
			替换replace
	字节   b前缀后跟ASCII字符
			b前缀后跟转义16进制 b'xFF'
			bytesarray(b'')
	编码   python字符串是对象,有两种,
			一个是str类型,可能是gbk或utf-8编码或者ascii编码 通过decode("gbk|ascii|utf-8")操作转换为unicode对象
			一个是unicode类型,通过encode("gbk|utf-8|ascii")转换为str对象
			判断对象类型 type(x) is unicode or type(x) is str
	
	库  excel库xlrd
				excel = xlrd.open_workbook(path)
				sheetnames = excel.sheet_names()
				sheet = excel.sheet_byname(name)
				cols = sheet.row_values(n)
				ctype = sheet.cell(row,col)
				value = sheet.cell_value(row,col);
	库  xml库xml.etree.ElementTree
	   			  root = ET.parse(".xml")
	   			  for child in root:
	   			  	for field in child:
	   			  		filed.tag 
	   			  		field.text

lua
	常量定义 luaconf.h       平台相关 搜索路径 堆栈大小 
	基础函数定义lua.h        以lua_为前缀,版本、REGISTERINDEX、GLOBALSINDEX、T* lua_Alloc lua_CFunction lua_is* lua_to* lua_push* lua_get* lua_set*
	辅助函数定义luaxlib.h    以luaL_为前缀
	基础库注册定义lualib.h   lua_open基础库相关函数定义,实现在各个库对应的.c内
	库实现
		 以lua_open为前缀,具体实现分散在不同的.cc文件内  
		 lauxlib.c  辅助库实现 luaL_loadfile luaL_loadbuffer luaL_reg/luaL_register luaL_check* luaL_opt* luaL_ref/unref luaL_newstate
		 lbaselib.c base库实现 g/setfenv g/setmetatable x/pcall tonumber/string rawg/set pack/unpack dofile/loadstring
		 liolib.c  io库实现 read write flush close open input output type
		 lmath.c   math库实现 abs ceil floor random randomseed cos sin acos asin tan atan exp log sqrt
		 lstrlib.c string库实现 lower upper len format reverse sub gsub find gmatch byte char dump match rep
		 ltablib.c table库实现 insert concat maxn remove sort
		 loslib.c  os库实现
		 loadlib.c 文件解释入口 require module seeall path cpath loaded preload loaders loadlib seeall
		 ldblib.c  debug库实现 traceback getenv gethook sethook getmetatable
		 linit.c  库注册入口函数整合
	常用API:  
		函数注册luaL_Reg注册函数结构体 luaL_Reg[] = { {"func_name",func},{"func_name1",func1} } luaL_register
		函数调用lua_call(L,narg,nresult) lua_pcall(L,nargs,nresults,err_func)
		table字段获取lua_getfield(L,stackid,k) lua_getmetatable lua_gettable lua_gettop lua_getglobal
		table字段创建lua_newtable lua_newuserdata
		lua_raw/get会在指定位置读取指定key的数据并压入栈顶
		lua_raw/set会移除栈顶数据(value和key),并设置指定table的key对应value
		lua_pop会移除栈顶指定个数的数据
		lua_push复制指定位置并压入栈顶
		lua_to系列不会移除栈数据 lua_toboolean lua_tocfunction lua_tointeger lua_tolstring lua_tonumber lua_tostring
		lua_is系列也不会移除栈数据 lua_isnil lua_isnumber lua_istable lua_isstring
		lua_ref会在注册表创建栈顶对象引用并返回索引 lua_unref解除引用 lua_getref获取引用对象并放到栈顶
	常用库函数
		coroutine 
			协同程序,非抢占式多线程,需要自己主动在不同的协程之间切换,同时只有一个协程在运行
			协程状态
				suspended 挂起状态,创建create或者yield之后处于这个状态
				running 运行状态,resume之后处于这个状态
				dead 死亡状态,没有遇到yield或者yield结束了,表示协程执行结束了
				normal 正常状态,协程套协程,执行到另一个协程去了
			协程操作
				status 获取协程状态
				create 传入一个执行函数,类似于UNITY的StartCoroutine
				resume 协程需要自己主动调用才可以开始或者继续执行
					   yield之后回到了主线程,主线程主动调用进入协程
					   resume可以在第一次启动时传递参数
					   resume可以传递参数作为初始化参数或者yield的返回值
				yield 只会出现在协程函数内部,yield可以传参数作为resume的返回值
				running 当前正在执行的协同程序
	变量定义位置
		全局表	      	LuaState.l_gt
		注册表 	      	LuaState.l_G.l_registry
		环境表          LuaState.env
		基础类型元表    LuaState.l_G.mt
		基础元函数名字 	LuaState.l_G.tmnames
		字符串哈希表    LuaState.l_G.strt
		GC对象          LuaState.gclist
		函数Env         Closure.env
		函数LocVar 		Proto.localvars
		函数UpVar       LClosure.upvals LuaState.openupval
						注意点
							如果upval不在直接外层函数内,那么这个upval也会成为直接外层函数的upval
							upval一定在外层函数的localvars或者upvals中
							外层函数的local是通过openupval间接引用的
		package.loaded  LuaState.l_G.l_registry._LOADED require会先到该表查找对应模块是否已加载,加载出来之后有返回值则为返回值,否则为true
		package.loaders LuaState.env
		module          push_module->mod_init->setenv
	变量引用关系
		LUA_TSTRING    	没有对其它对象的引用
		LUA_TTABLE 		keys values array metatable
		LUA_TFUNCTION   proto upvals
						CCLOSURE upvals proto
						LCLOSURE upvals
						PROTO    source constants upvalnames varnames
		LUA_TUSERDATA   envtable metatable
		LUA_TTHREAD     luastate
	jit优化
        原理
            JIT是把字节码编译成机器码,放到可执行内存中执行,需要申请带可执行权限的内存空间
        工具
            jit/*.lua 可以用来控制JIT的编译过程
            开启/关闭JIT模式 jit.on/jit.off 
        问题1
            ARM限制跳转指令只能跳转前后32MB的空间,如果连续的64MB空间内被其他代码占用,LUAJIT就分配不出可执行内存
            能否进行JIT只能不断重复尝试编译,导致性能急速下降,如何预分配这些内存空间?
        问题2
            ARM可用寄存器比X86少,LUAJIT会尽可能使用寄存器存储LOCAL变量,LOCAL太多会导致寄存器分配失败
        问题3
            调用C函数的代码无法JIT,可以使用FFI库调用C函数是可以JIT优化的
        问题4
            某些字节码无法JIT优化,有哪些?

OC
	面向对象的语言
	基础函数类库 
		#import <Foundation/Foundation.h>
		日志打印:NSLog
		字符串:NSString
	类声明
		声明类以@interface开头,@end结尾 
		@interface cls : NSObject
		@end
	类实现
		实现类以@implementation开头,以@end结尾
		@implementation cls
		{
			大括号内部是成员变量
		}
		@end
	类函数:
		-(void)name:(bool)param1 paramt:(int)param2;  
		-是成员函数,+是静态函数
		:前面是函数名字和返回值
		[object func:param1 paramt:param2]
	类对象:
		创建
			cls* ptr = [[cls alloc] init];
			类对象创建使用中括号,前面是类名,后面是分配函数,在后面是初始化函数
		释放
			[cls release:1];
			OC不支持垃圾回收,用完需要释放,参数用冒号表示开始

Java:
	JDK分类
		J2ME J2SE J2EE分别是针对移动平台和嵌入式、PC平台、企业版设计的JDK
		JDK是Java开发工具包,包括了专用开发环境JRE、Java编译运行工具
		JRE是Java的公共运行环境,包括了JVM虚拟机和核心类库
	JDK工具
		javac 编译工具,把.java编译为.class字节码
		jar 打包工具,把.class文件打包在一起
		java 运行工具,运行.class后缀的java程序
		javap 反编译
	类库
		java.lang 系统基础库,不引入就可以使用的包
		java.io   IO相关类库
		java.nio  非阻塞IO相关类库
		java.net  网络相关类库
		java.util STL相关类库
		java.sql  数据库操作类库
	包
		package x; 类似命名空间,包名是当前java文件的目录结构
		import x;  导入java类库,类似引用命名空间
	线程
		ASyncTask 包:android.os,使用方式:执行execute或executeOnExecutor

Html:
	版本: <!DOCTYPE HTML>
	头部: <head></head>
		编码: <meta charset="utf-8">
		标题: <title></title>
	内容: <body></body>
		换行: <br/>
		字体: <font size="6" color="ffffff"></font> <b></b> <i></i> <sub></sub> <sup></sup>
		链接: <a href=url>链接内容描述</a>