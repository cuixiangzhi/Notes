基础知识
    appID:      应用的唯一标识id
    appKey:     应用的账号和秘钥成对出现,appID和appKey可以一致(针对不需要设置账号权限的服务)
    appSecret:  应用的公钥密码
    token:      应用敏感数据获取时用于验证,使用appID、appKey、appSecret进行初始化后,会生成一个acces_token,用于后续的API调用
安卓SDK
    jre:    基础运行环境(java命令)
    jdk:    基础开发类库、工具包
    sdk:    应用开发类库、工具包(buildtool platform com.*)
    ndk:    安卓C/C++(so文件)编译工具包,Application.mk配置平台相关(stl.abi.optim.platform) Android.mk配置编译相关(模块名字.编译选项.文件路径.编译目标)
    gradle: 安卓自动化构建工具(caches目录下包含各种依赖库com.*)
    jar:    java字节码集合,包含一个META-INF/MANIFEST.MF清单文件和一组.class文件
    aar:    aar是一个包含自定义UI和字体等资源和代码的类库,例如调用API之后弹出一个窗口,窗口的UI和字体都是库内的
    dex:    apk的java字节码会转换成dex字节码,由android系统的dvm(dalvik)虚拟机执行
    assets: 有些jar库使用了外部的资源或者配置文件,需要放在assets(对应于apk/assets目录)文件夹下
    obb:    googleplay对apk大小做了限制,需要把apk的一部分资源拆分出来打成obb包(main|patch.版本号.包名.obb)
    keystoreName keyaliasName
        安卓应用打包签名所需要的文件,用于标识一个应用,相同签名的应用会覆盖安装
        这个文件一般是渠道给的,用于发布APK使用
    AndroidMainfest:
        安卓apk配置文件
            首先是一个xml文件头 <?xml version="1.0" encoding="utf-8"?>
            然后是manifest头
                xmlns:android=命名空间
                package=包名
                android:vesionCode=数值(用于表示APP更新过几次,比较哪个是最新的) 
                android:versionName=字符串(显示用)
                android:installlocation=
            接下来是配置内容
                SDK版本配置
                    <uses-sdk android:minSdkVersion=16 android:targetSdkVersion=22 android:maxSdkVersion=26 />
                权限配置
                    <uses-permission android:name="android.permission.INTERNET" />
                特征配置
                    <uses-feature android:name="android.hardware.camera" android:required="true|false" >
                屏幕配置
                    <supports-screens android:resizeable=true android:smallScreens|normalScreens|largeScreebs|xlargeScreens|anyDensity/>
                应用配置
                    <application android:label="@string/app_name" android:icon="@drawable:app_icon" android:debuggable调试 android:usesCleartextTraffic明文HTTP android:largeHeap >
                        <!-- activity       activity是一个活动窗口,使用setContentView来显示不同的控件 -->
                        <!-- launchMode     singleTop栈顶单例,打开栈顶的activity singleTask栈内单例,弹出它上面的所有activity-->
                        <!-- intent-filter  startActivity或startService的参数是一个intent,intent会和activity的filter配置进行匹配-->
                        <activity android:name="com.xx.xx.Unity3dPlayer"android:label="@string/app_name" android:launchMode="singleTop|singleTask"> 
                            <intent-filter>
                                <action android:name="android.intent.action.MAIN" />            action.MAIN表示主activity
                                <category android:name="android.intent.category.LAUNCHER" />    category.LAUNCHER表示在桌面添加启动图标
                            </intent-filter>
                            <meta-data android:name="key" android:value="value" />
                        </activity>

                        <!-- provider是一个应用之间共享数据的方式,继承自ContentProvider,默认有一个文件实现FileProvider-->
                        <provider
                            android:name="com.xx.xx.XXProvider" 类名,一般使用supportv4库的FileProvider(android.support.v4.FileProvider)
                            android:authorities="com.xx.xx"     唯一标识
                            android:exported=""                 是否可被其它应用启动
                            android:grantUriPermission=""       授权文件访问权限
                            >                                   
                            <meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:value=@xml/file_paths/>
                        </provider>

                        <!-- service是一个在后台运行的服务,start/stopService启动/关闭和应用无关的服务,bind/unbindService启动/关闭和应用绑定的服务 -->
                        <service 
                            android:name="com.xx.xx.XXService" 服务名字
                            android:exported="false"           是否可被其它应用启动
                            android:permission=""              启动该服务需要的权限
                            android:process=""                 是否在单独的进程中执行
                            >
                        </service>

                        <!-- receiver是一个继承自BroadcastReceiver的接收器,接收来自sendBroadcast的广播,xml内配置之后可以在应用没有运行的时候接收广播-->
                        <receiver 
                            android:name="com.xx.xx.XXReceiver" 类名
                            android:process="">                 进程
                            <intent-filter>
                                <action android:name="android.intent.action.CAMERA_BUTTON"> 系统事件广播或者应用自定义广播
                            </intent-filter>
                        </receiver>
                    </application>
苹果SDK
    .mm         oc语言的源代码文件,放入iOS/模块名字/ 目录下
    .a:         静态库,生成方式(gcc编译*.o ar&rcs打包成*.a),查看CPU架构lipo -info 
    .framework  系统的.framework文件属于动态库,个人创建的属于静态库 .framework包含资源文件
    .dylib      动态库,一般都是系统库,在xcode内以*.tbd形式存在,iOS不支持自己实现动态库
    target      编译目标,继承project的编译配置
    scheme      编译任务,指定编译哪几个目标
    .xcarchive  中间文件(包含了.app和dSYM符号表文件),生成命令 xcodebuild archive -scheme * -configuration * -archivepath *.xcarchive
    .ipa        安装包,生成命令 xcodebuild -exportArchive -archivePath *.xcarchive -configuration D|R -exportPath *.ipa -exportOptionsPlist
    .app        执行程序
    .appid      分为个人、公司、企业三种,企业账号只能用来测试(不能发布到appstore)
    .autosign   给当前APPID生成开发证书和描述文件,描述文件包含了AppID、BundleID、证书、设备的关联信息
    .certificates 分为开发证书和发布证书,通过钥匙串生成CSR文件用来申请证书并生成描述文件,导出p12文件给项目用
    .provisioning 分为开发、临时发布(ad-hoc企业版,限制设备数量)、正式发布(in-house企业版,不限制设备数量)
    UnityXCode依赖库配置
        xcode工程文件是*.xcodeproj文件夹,具体配置文件是*.xcodeproj/*.pbxproj文件
        xcode工程配置包含两种类型,一种是库的依赖、搜索路径;另一种是k/v形式的编译配置
        unity支持导出xcode之后修改pbxproj配置文件 OnPostProcessBuild(BuildTarget buildTarget, string buildPath)
            PBXProject pbx = new PBXProject(); pbx.ReadFromFile(PBXProject.GetPBXProjectPath(buildPath));
            PlistDocument plist = new PlistDocument(); plist.ReadFromFile(buildPath + "/Info.plist");
            ParseFromConfigJson(); CreateDirectory(buildPath + "Libraries/Plugins/iOS/"); CreateDirectory(buildPath + "Framework/Plugins/iOS/");
            开始根据配置文件修改工程设置
            string buildTarget = pbx.TargetGuidByName("Unity-iPhone");
                库搜索路径
                pbx.SetBuildProperty(buildTarget,"FRAMEWORK_SEARCH_PATHS","$(SRCROOT)/Frameworks/Plugins/iOS/|$(inherited)");
                pbx.SetBuildProperty(buildTarget,"LIBRARY_SEARCH_PATHS","$(SRCROOT)/Libraries/Plugins/iOS/|$(SRCROOT)/Libraries|$(SRCROOT)|$(inherited)");
                proj.AddBuildProperty(target, "LIBRARY_SEARCH_PATHS", json.lib_searchpath[j]);
                proj.AddBuildProperty(target, "FRAMEWORK_SEARCH_PATHS", json.framework_searchpath[j]);
                系统动态库引用
                pbx.AddFrameworkToProject(buildTarget,"frameworkName",false);
                系统动态库引用
                pbx.AddFileToBuild(buildTarget,pbx.AddFile("usr/lib/dylibName","Frameworks/Plugins/iOS/",PBXSourceTree.Sdk));
                外部静态库引用
                pbx.AddFileToBuild(buildTarget,pbx.AddFile("Frameworks/Plugins/iOS/frameworkName","Frameworks/frameworkName",PBXSourceTree.Source));
                外部静态库引用
                pbx.AddFileToBuild(buildTarget,pbx.AddFile("Libraries/Plugins/iOS/libName","Libraries/libName",PBXSourceTree.Source));
                外部文件引用
                pbx.AddFileToBuild(buildTarget,pbx.AddFile("Libraries/Plugins/iOS/filePath","Libraries/filePath",PBXSourceTree.Source));
                编译配置
                proj.SetBuildProperty(target, json.buildset_set[j].key, json.buildset_set[j].value);
                proj.UpdateBuildProperty(target, json.buildset_add[j].key, new List<string>() { json.buildset_add[j].value },new List<string>());
                Info.plist配置
                PlistElementDict dict = plist.root.AsDict();
                for (int j = 0; j < json.plistset.Length; j++)
                {
                    dict.SetString(json.plistset[j].key, json.plistset[j].value);
                }
        JSON文件数据结构
        [System.Serializable]
        public class Unity_Xcode_Json_KV
        {
            public string key;
            public string value;
        }

        [System.Serializable]
        public class Unity_Xcode_Json
        {
            public string[] internal_frameworks;
            public string[] internal_dynamiclibs;
            public string[] external_frameworks;
            public string[] external_staticlibs;
            public string[] external_files;
            public string[] lib_searchpath;
            public string[] framework_searchpath;
            public Unity_Xcode_Json_KV[] buildset_set;
            public Unity_Xcode_Json_KV[] buildset_add;
            public Unity_Xcode_Json_KV[] plistset;
        }