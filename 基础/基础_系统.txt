系统组成
	   单内核系统核心模块在一起,模块之间交互使用函数调用
	   微内核系统模块独立,模块之间交互使用进程通信
	   模块实现 模块编译 模块管理
	   系统启动
			  通电->CPU执行BIOS固定地址跳转指令->
			  BIOS程序启动->POST加电自检->
			  必要硬件BIOS初始化->次要硬件初始化->磁盘读取MBR
			  加载kernel,启动init进程,启动登录tty,
			  tty调用open打开终端等待用户输入用户名,
			  启动login进程等待输入密码,
			  登录成功,切换到当前用户主目录chdir,修改终端拥有者chown,修改终端权限chmod,设置进程组ID
文件管理
		文件系统
			磁盘文件系统,定义了磁盘分区的存储、读写方式,例如FAT32 NTFS NFS EXT等等,文件存储的是INODE数据(偏移大小日期等等)
			虚拟文件系统,对文件系统的抽象,封装了不同文件系统之间的差异性
			机械硬盘由盘片、磁道、扇区、磁头构成,硬盘读写数据需要经过磁头寻道、盘片旋转、读写数据三个阶段
			硬链接: 文件名不同,INODE相同,文件内容改变之后互相不影响
			软连接: 文件名不同,快捷方式 ls -s
		文件编码
			大端模式: 把字节按顺序存储,即低地址存储高字节,高地址存储低字节
			小端模式: 正好相反
			字符集
				许多字符的集合,每个字符有一个编号,例如UNICODE字符集 ANSI字符集
				本地系统语言及字符集,国家_语言.字符编码(zh_cn.utf-8) locale/setlocal查询修改本地系统编码 mbstowcs/wcstombs本地编码和Unicode编码转换
			字符编码
				字符集编号的存储表示方式,也就是存储格式,例如UNICODE字符集的编码(UTF8 UTF16 UTF32等等) ANSI字符集的编码(GB2312 GBK BIG5等等)
			语言编码
				C# 		string是unicode对象,静态字符串初始化会根据cs文件编码解码,一个char是一个字符
				C++ 	string是char数组,wstring是wchar_t数组,_T():UNICODE字符集会添加L前缀,表示字符串类型为wchar_t
				python  分为str和unicode两种对象,decode解码为unicode对象,encode编码为str对象,encode方式有gbk、utf8等等
				console windows默认是GB2312编码,可以使用chcp切换编码 jenkins默认是utf-8编码
			编译器编码
				MSVC
					源码编码: 源代码文件的编码,分为带BOM和不带BOM,UTF-8是0xEFBBBF
					程序编码: 二进制文件内字符编码,编译时会根据系统编码来设定
				GCC
					源码编码: -finput-charset=utf-8 不设置则默认UTF-8
					程序编码: -fexec-charset=utf-8  不设置则默认UTF-8
		文件格式
			ELF格式 unix下二进制文件格式
				包含一个ELF文件头、一个程序头表、一个分节表(可选)、和多个SEGMENT(每个SEGMENT包含多个权限相同的SECTION)
				.text代码段 .data|.bss|.rodata数据段 .init代码段(main进入前) .fini代码段(main退出后) .dynsym导出符号表 .dynstr字符串表
				__attribute__(constructor()|destructor())
		文件权限
			文件拥有者-拥有者同组用户-管理员 rwx-rwx-rwx
			groupadd -g id name 添加用户组并指定ID和组名
			useradd -g groupname -d dir -m username 添加用户并指定用户组、主目录、用户名
			userdel -r username 删除用户及其主目录
			passwd username 修改用户密码
内存管理
	    内存访问
			MMU:接收CPU的内存访问请求,把虚拟地址转换为物理地址(L1 L2 主存)
			虚拟地址:页表索引(占用20位)+页内偏移(占用12位)
			页表:每一项占用32位,其中20位对应物理页基地址,12位对应物理内存状态(访问权限、是否缺页)
			进程:每个进程都有自己的页表,切换进程会同时更新MMU内的页表地址
			TLB:页表访问缓存,降低页表查找次数(页表也是存储在物理内存中的)
		内存布局
			stack-map-heap-bss-rwdata-rodata-code
		内存分配
			brk系统调用分配小于128KB内存,中间内存碎片无法释放,mmap系统调用分配大于128KB内存,自由释放
			具体大小可由M_MMAP_THRESHOLD来调节 M_TRIM_THRESHOLD调节堆碎片紧缩值

			new/delete new[]/delete[] 分配/释放内存,然后调用构造/析构函数
			malloc/free 只负责分配/释放内存
			mmap(NULL,size,PROT_READ|PROT_WRITE|PROT_EXEC,MMAP_PRIVATE,fd,offset);
			munmap(PTR,size);
				头文件 sys/mman
				mmap有SHARED和PRIVATE两种方式,即共享内存和私有内存,前者会写入文件,后者不会
				mmap共享模式下映射大小不大于文件大小,多余部分不会写入文件(页对齐)
				fseek可以设置文件大小
				msync同步共享内存写入到映射文件
			shmget(key,size,IPC_CREAT)
				头文件 sys/shm sys/ipc
				SHM需要先创建共享内存,然后映射到进程地址空间内,shmat(&sid,NULL,0);
				取消映射使用shmdt(PTR);
				删除内存使用shmctl(sid,IPC_RMID,NULL);
				shm映射内存不会写入文件,进程退出不删除则系统关机才会删除
			FileMap
				windows共享内存机制
				创建共享内存 CreateFileMapping(INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE,0,SIZE,KEY);
				打开共享内存 OpenFileMapping(FILE_MAP_ALL_ACCESS,TRUE,KEY);
				进程映射内存 MapViewOfFile(handle,FILE_MAP_ALL_ACCESS,0,0,0);
				取消内存映射 UnmapViewOfFile(PTR);
				关闭共享内存 CloseHandle(handle)
			VirtualAlloc
				ntdll的API,windows虚拟内存
			DLL映射
				映射到内存,内存修改不会写入文件
		内存权限
			mprotect(ADDR,LEN,PROT_READ | PROT_WRITE | PROT_EXEC)
		内存占用
			VSS 虚拟内存占用(进程申请的所有内存)
			RSS 实际物理内存(进程内存+共享库内存)
			PSS 实际物理内存(进程内存+共享库内存平均值)
			USS 实际物理内存(进程内存)
进程管理
		进程关系
			父子进程: fork创建进程,pid为0是子进程,大于0是父进程,调用execl(path,name,args)覆盖进程空间执行新程序代码
			僵尸进程: 子进程的退出状态,等待父进程调用waitpid(-1,NULL,0)回收;
			孤儿进程: 子进程的状态,父进程退出但是子进程没有退出,子进程会由init进程收养
			守护进程: 孤儿进程周期检测目标程序,监视运行状态并在目标崩溃后重启
		进程外挂
			ptrace提供控制另一个进程的能力,检测、修改代码、数据、寄存器、断点、注入、跟踪
			调试 PTRACE_ATTACH PTRACE_DETACH PTRACE_CONT PTRACE_SINGLESTEP PTRACE_SYSCALL
			读取 PTRACE_PEEKTEXT PTRACE_PEEKDATA PTRACE_PEEKUSR
			写入 PTRACE_POKETEXT PTRACE_POKEDATA PTRACE_POKEUSR
线程管理
		线程进程
			进程的创建需要分配独立的地址空间,代码段、数据段、堆栈段
			线程的创建只需要很小的空间,比进程消耗小很多,线程切换比进程切换速度快
		线程创建   				  
			pthread_create(pthread_t &pid,NULL,void* loopfunc,this);
			CreateThread(NULL,0,DWORD WINAPI loopfunc,this,DWORD &pid)
			pthread_self()获取线程ID
		线程退出
			pthread_cancel();
			pthread_exit(NULL);
		线程回收
			默认创建的线程处于joinable(可以通过设置pthread_attr来改变)状态,需要调用pthread_join(pid)之后才会回收已退出的线程的资源
			调用pthread_detach后线程处于游离状态,由操作系统来回收资源
		线程状态
			不同的操作系统有不同的线程模型,同时对于了不同的线程状态
			通用状态
				新建: 已经创建,等待start
				就绪: 可以执行,等待cpu
				运行: 正在执行,执行code
				阻塞: 等待事件,等待阻塞:event.wait(等待event.notify|pulse) 睡眠阻塞:sleep(等待timeout|interrupt)
				死亡: 执行结束,等待主线程回收资源
		线程同步
			共享锁和互斥锁属性
				pthread_mutex|rwlockattr_init(&attr)
				pthread_mutex|rwlockattr_setpshared(&attr,pshared)
			共享锁和互斥锁(通过属性指定是进程锁还是线程锁,默认是线程锁)
				pthread_mutex|rwlock_init(&handle,&attr)
				pthread_mutex|rwlock_lock(&handle);
				pthread_mutex|rwlock_unlock(&handle);
				pthread_mutex|rwlock_destroy(&handle)
			信号量(头文件semaphore.h,通过pshared指定是进程共享还是线程共享)
				创建 sem_init(sem_t, pshared, value)
				等待 sem_wait(sem_t)
				释放 sem_post(sem_t)
			自解锁(互斥锁)
				对代码块的执行进行加锁,例如c#的lock,java的synchronized,c++的mutex(构造时lock,析构时unlock)
			注意点
				锁对象设为私有变量,外部不可访问,尽量使用trylock tryenter尝试加锁,避免长时间等待
				注意循环锁定,lock(A)调用外部代码执行lock(A)
		数据队列
			环形缓冲区
				一个size大小的buffer,head指向第一个可读的位置,tail指向第一个可写的位置
				buffer判空 head==tail
				buffer空闲 head大于tail则left=head-tail-1 head小于tail则left=total-tail-1+head
				buffer有效 head大于tail则left=total-head+tail head小于tail则left=tail-head
			无锁逻辑
				读操作只修改head的值,读取之前先把tail值缓存下来,避免读的过程中被修改,读完之后在修改head的值
				写操作只修改tail的值,写入之前先把tail值缓存下来,写完之后在修改
进程通信
		本地通信
				mmap shm filemap
		网络通信
基本命令
		超级用户:系统管理员,拥有所有权限,UID默认为0
		系统用户:创建时用-r来指定,一般用来维持某个服务的运行,不会用来登录,有一定权限,UID范围一般是1-499或999
		普通用户:默认新建账号都是普通用户,只能执行/bin /usr/bin /usr/local/bin home目录下的命令
		添加系统用户组
			linux groupadd gname -r -g gid
			macos dscl . -create /Groups/gname
		添加系统用户
			linux useradd uname -r -u uid -g gid -d homedir
			linux passwd uname
			macos dscl . -create /Users/uname UniqueID uid
			macos dscl . -passwd /Users/uname password
			macos dscl . -delete /Users/uname
			macos dscl . -append /Groups/gname GroupMembership uname
		执行文件加锁
			flock -xn path.lock -c 'sh cmd' -n表示加锁失败不等待 -c后边是sh文件