界面
    字体规范
        公共字体 TTF字体(1个)
    图集规范
        公共图集 2048*2048*(3~4个,1个物品图集,1个通用背景图集,1个通用小图图集)
        功能图集 2048*1024|1024*1024*(3~5) 1024*512|512*512*(不限制)
        功能背景 越少越好,最好没有
        功能图标 使用动态图集,大图单个使用,提供缓存机制
        压缩格式 统一使用ASTC6x6 关闭MIPMAP 关闭READ/WRITE
    预设规范
        图集使用 只能使用公共图集和对应系统的功能图集
        背景使用 只能使用公共背景和对应系统的功能背景
        图标使用 预设上不保留对图标的引用,通过代码动态加载
角色
    身体 LOD0:5000面_3000顶点_1.0_1.0 LOD1:2500面_1600顶点_0.7_0.5 LOD2:600面_500顶点_0.35_0.125 76根骨骼
    衣服 LOD0:1700面_1400顶点_1.0_1.0 LOD1:860面_810顶点_0.24_0.5  LOD2:430面_470顶点_0.19_0.25  31根骨骼(带物理模拟)
    脑袋 LOD0:2200面_1400顶点_1.0_1.0 LOD1:1100面_768顶点_0.08_0.5 LOD2:550面_420顶点_0.07_0.25  87根骨骼(15根捏脸) 
场景
    地形 分辨率 高度图 LOD分块 LOD距离
    植被 密度
特效
    GM命令连续播放特效 检测overdraw或者fps测试性能消耗
代码
    JobSystem
    DrawCall StaticBatch DynamicBatch
    Physics
    Animator
    UIUpdate
    GPUSkin
    GPUAnim
    GCAlloc
    CacheMiss
    ShaderWarmup
    GameObject.SetPos
UGUI ReBuild是UI元素重建会导致SendWillRenderCanvases Canvas.ReBatch是多线程的(UI元素变化时整个Canvas要重建)
渲染
    bandwidth数据带宽
        开启遮挡剔除
            尽可能的把不需要渲染的物体裁剪掉,减少数据传输同时减少计算量
        使用LOD和GPUInstance
            远处的物体用低模和实例化渲染都可以减少数据量,降低shader计算量
        开启MIPMAP
            远处的物体使用更小的纹理,降低纹理带宽
    shader计算复杂度
        使用向量运算
            GPU执行的都是向量运算,float和float4的计算耗时是一样的,尽量合并成向量去做计算和赋值
        减少分支语句
            GPU以wrap来执行shader指令,一个wrap包含N个thread,它们的指令完全相同并且同步执行,遇到分支之后会产生新的wrap
        降低变量精度
            精度越低越好,保证范围的情况下使用最低的精度
        减少采样次数
            访问周期:寄存器(1)->共享内存(1~32)->L1缓存(1~32)->L2缓存(32~64)->纹理/常量缓存(400~600)->全局内存
        降低分辨率
            降低屏幕分辨率可以减少需要计算的像素数,从而降低GPU计算量
    overdraw重复绘制
        像素块
            GPU会以2x2的像素块为单位分配给一个core去执行,每个core包含4个thread,每个thread只负责一个像素
        减少AlphaTest和AlphaBlend
            这两个操作都在ZTest之后执行,开启之后无法进行Early-Z
        开启背面裁剪
            不开启两个面都会渲染
        控制粒子数量
            大量的小物体(粒子、植被、沙石、毛发等待)由于像素块的划分机制会造成严重的overdraw
    tbdr优化
        FrameData拷贝
            尽量减少触发FrameData和FrameBuffer之间互相拷贝的操作
    viewmode
        gameview和sceneview镜头同步 使用overdraw模式查看性能消耗
动画
    骨骼动画
	关键帧    AnimationClip,记录了每根骨骼相对于父骨骼的位置、旋转、缩放
	绑定骨骼  SkinnedMeshRenderer.bones,记录了当前SkinMesh的动画绑定的骨骼
	绑定姿势  Mesh.bindposes,记录了顶点变换到骨骼坐标系下的变换矩阵(bone.worldToLocal * renderer.localToWorld)
	绑定权重  Mesh.boneWeights,记录了每个顶点绑定的骨骼和权重
	蒙皮公式  worldPos = bindWeight * bindBone.localToWorld * bindBone.bindPose * vertex,每一帧先计算动画得出骨骼的变换矩阵,然后根据绑定骨骼和权重计算
	动画融合  连续播放的两个动画衔接的过程
	动画混合  同时播放的两个动画衔接的过程 Pelvis混合下半身 Spine混合上半身 LayerBlendPerBone按照骨骼递归按照比例混合,SlotNode控制输入和Slot蒙太奇的混合
	IK动画
		子骨骼带动父骨骼运动,给定子骨骼的目标位置和上一级父骨骼的朝向,可以根据余弦定理计算出父骨骼的位置
		IKBone:需要移动到指定位置的骨骼 JointBone:IK骨骼的父骨骼 RootBone:JointBone的父骨骼
    捏脸动画 表情用内骨骼 捏脸用外骨骼 额头(左中右) 眼睛(左右) 脸颊(左右) 耳朵(左右) 鼻子 鼻翼(左右) 嘴巴 嘴唇(上下) 下巴
	RootMotion
		ApplyRootMotion开启之后会把根骨骼的位移加到模型根结点上(UE4会在移动组件里添加RootMotion的计算)
	GPUInstance
		烘焙 预先把骨骼动画数据烘焙到纹理中,纹理存储动作每一帧的变换矩阵(root.worldToLocal * bone.localToWorld * bone.bindPose)
		数据 静态网格(T-POSE) 绑定权重(顶点属性4*2,boneIndex|boneWeight) 动画贴图(变换矩阵4*4*boneCount*frameCount) 实例变换(变换矩阵,localToWorldArray)
    变形动画
        顶点数据  需要多套数量相同的顶点数据,只能是静态网格
        插值计算  可以在GPU上用额外的顶点属性保存顶点数据来插值
    动画状态机 曲线动画 分层分块 地面状态.直立.蹲下.趴下 空中状态    逐骨骼分层混合 动画后处理(AimOffset 脚部IK 手部IK)
    动画LOD LOD0:IK、LookAt、表情、脚印、全身动画   LOD1:全身动画简化   LOD2:空动画 
    IK设置 Unity:Layer->IKPass->OnAnimatorIK(layer)->SetIKPosition&&Weight(IKBone,position&&weight)->SetIKRotation&&Weight(IKBone,rotation&&weight)
    SetLookAtIK(weight,bodyweight,headweight,eyeweight) 
内存
    代码内存
        table_memory
            数据表需要自定义数据格式,支持分行读取,支持LRU缓存
        gcalloc_memory
            closure_memory
                委托、协程、Lambda函数等最终都会生成一个class对象,传递函数给委托类型时会创建委托对象,每次开启协程都会创建协程对象
            array_memory
                调用某些API返回数组时有内存分配,例如GetComponents Mesh.vertices Physics.RaycastAll ParticleSystem.Start|Stop|Clear
            proto_memory
                协议的收发会分配很多小内存,序列化发送时最好直接写到缓冲区,反序列化尽量支持消息池
            boxing_memory
                params_memory
                    禁止使用可变参数,重载多个函数来替代可变参数
                comparer_memory
                    对值类型做Key相等比较时如果没有实现IEquatable接口,会在比较时进行装箱(默认使用ObjectEqualityComparer来获取HashCode并进行Equals比较,60BGC)
            string_memory
                统一日志接口,区分发布和调试接口,禁止使用..拼接日志
        component_memory
            减少没有意义的Actor、Component的创建,可以稍微降低内存和实例化开销
        rendertexture_memory
            RT绑定的是FB所以无法压缩,对每个RT指定名字以方便跟踪,能干掉的都干掉
    资源内存
        shader_memory
            shader_feature
                只生成bundle内引用到keyword的变体
                使用#pragma shader_feature keyword来定义
                使用[Toggle(feature) ..]在材质上显示该选项
            multi_compile
                生成所有keyword对应的变体
                使用#pragma multi_compile keyword来定义(keyword最多256个,超过这个值会报错)
                使用Shader.EnableKeywords和Material.EnableKeywords开启全局或单个材质的宏定义
            variants
                宏定义太多导致shader变体很多,不仅增加了build时间,运行时由于变体太多增加加载和编译时间并增加内存占用
                shader_fallback:      关闭fallback可以减少变体数量(keyword变少)
                i_preprocess_shaders: 打包后处理阶段,可以实现shader变体的剔除
                shader_variant_collection: shader变体集合(指定包含哪些shader和对应variant),可以用来在启动或空闲时预编译(执行wramup)
        texture_memory
            upload_buffer
                从内存中往显存上传的时候,会先放到一个缓冲区内,缓冲区满了才会上传
            read/write
                开启之后内存中会保留一份
            mipmap
                开启之后内存占用会增加30%,但是可以提高渲染效率(降低显存带宽、提高缓存命中率)
            streaming
                根据poolsize和sceneview情况动态加载/卸载纹理的mipmap,poolsize需要根据机器内存指定或者动态调整
        mesh_memory
            MeshCompression
                降低硬盘占用,开启之后会影响下面两个选项,一般关闭
            OptimizeMeshData
                减小打包包体,打bundle时会剔除shader没有使用到的顶点属性
            VertexCompression
                降低内存占用,降低顶点属性的精度(float->half),针对300顶点以上、未开启R/W的网格生效
            Read/Write Enabled
                开启该选项的网格顶点属性会在内存中存在两份(显存+内存)
            DynamicBatching
                开启之后在打包时会把支持动态批处理的网格的R/W选项开启
            StaticBatching
                开启之后引用同一份网格的对象变成多个实例(引用一个StaticMesh的不同部分)
            SkinnedMesh
                由于骨骼动画需要在CPU端每帧计算顶点位置,会强制开启R/W
            ParticleMesh
                粒子和骨骼动画类似,因为要做位置计算,会强制开启R/W
        animation_memory
            animation_cache&io
                游戏内角色会有很多休闲动作,需要支持动态加载和卸载,支持LRU缓存
            animation_frame
                动捕的关键帧几乎是满帧,需要简化(删除缩放曲线、简化直线帧)
        audio_memory
            dsp_buffer
                FMOD播放声音会先写入到一个BUFFER内,BUFFER填充满了才会播放,太大会导致声音延迟,太小CPU消耗上升
            speaker_mode
                FMOD使用双声道内存会占用两份,最好选用mono模式(默认是stereo)
            fmod_bank
                master.string.bank存储了所有event的路径信息,可以通过getStringInfo获取资源信息(event:* bank:* vca:* bus:*)
                name.bank文件是由metadata|sampledata|streamingdata三部分组成,loadBank时可以指定只加载metadata,sampledata自己控制加载
            audio_format
                音乐:Streaming+Vorbis 音效:DeCompressOnLoad+ADPCM 录音频率:8KHZ
            audio_cache
                2D:1 2D_ONE:1 3D:5 BG:1 CG:2
        video_memory
            video_format
                720P:低码率1Mbps,中码率2Mbps,高码率4Mbps 1080P:低码率2Mbps,中码率4Mbps,高码率8Mbps
                MP4格式:H264视频编码和AAC音频编码 WEBM格式:VP8视频编码和VORBIS音频编码
        bundle_memory
            typetree
                为了做不同版本的类型兼容,开启之后会写入变量类型的信息
            lz4&lzma
                lz4分块解压,lzma是整体压缩,lz4占内存小,解压速度快
            size&count
                每个包多大,什么资源打一个,文件头占用内存是否远小于资源内存
音频
    音频采样 8kHZ:人声 22kHZ:广播 44kHZ:音频 声道:Mono&Stereo 编码:PCM无损1411kbps,AAC有损256kbps,OGG有损128kbps
    音频格式 中长音乐:Streaming+Vorbis 短音效:DeCompressOnLoad+ADPCM
    音频数量 2D:1 2D_ONE:1 3D:5 BG:1 CG:2
视频
    视频码率 720P:低码率1Mbps,中码率2Mbps,高码率4Mbps 1080P:低码率2Mbps,中码率4Mbps,高码率8Mbps
    视频格式 MP4格式:H264视频编码和AAC音频编码 WEBM格式:VP8视频编码和VORBIS音频编码
纹理
动画
阴影
    1.LODGroup
        使用LODGroup组件设置Render列表,根据网格占屏比选择适当的LODMESH,支持淡入淡出(unity_LODFade)
        物体占屏比是通过当前屏幕空间AABB和近平面时物体的AABB的比例值来计算
    2.ShaderLOD
        shader实现多个不同LOD的subshader,LOD越低效果越差但是性能越好,例如PBS有高中低三个版本
        shader.globalMaximumLODLevel设置当前渲染质量,低于该值的shader的pass才会被使用
        shader.maximumLodLevel设置特定shader的渲染质量
    4.ParticleLOD
        prefab级别的LOD:按照LOD距离或者平均帧率来计算出当前prefab应该用哪一级LOD,每隔一段时间检测一次
        system级别的LOD:指定每个ParticleSystem所属的LOD级别,LOD变更的时候进行比较
    4.QualityLevel
        运行时通过修改Unity的渲染配置,来提高质量或者降低消耗,通过QualitySettings.SetQualityLevel调节
        渲染
            PixelLightCount Important模式一定是逐像素的,Important个数小于指定个数会选取Auto模式的作为逐像素光源
            TextureQuality  降低显存占用(0级MipMap,贴图R/W一定要关闭),FullRes是完整分辨率,HalfRes是一半分辨率
            AnisoTropicTex  各向异性纹理采样是否开启,开启之后远处的细节会变清晰,PerTexture会使用贴图的设置,ForceOn会强制设置所有贴图
            AntiAliasing    MSAA抗锯齿的采样点个数,可以是2x、4x、8x,需要配合Camera的MSAA选项使用
            SoftParticles   开启之后粒子会计算深度差dz来柔化边缘(当粒子距离物体特别近的时候穿插不会出现硬边),计算需要深度图
            Resolution      通过ScreenAPI设置渲染目标分辨率或者自定义RT作为渲染目标或者使用Camera的动态分辨率选项
        阴影
            Shadows          软阴影会多一步模糊操作,可以减弱锯齿
            ShadowDistance   距离摄像机的深度值低于该值时使用实时阴影,同时该值会影响划分阴影层级的范围
            ShadowNearOffset 直接使用8个顶点计算时可能会导致更外面的物体没有产生阴影(比如高大的建筑物在视椎体外面)
            ShadowCascades   把观察体划分为N个等级,每个等级根据8个顶点和平行光方向计算正交摄像机的AABB,提高近处物体的阴影深度的精度
        其它
            BlendWeights     蒙皮顶点最多受几根骨骼影响,减少该值可以降低蒙皮计算量,提升CPU性能
            VSyncCount       关闭后Unity会全速跑Update,否则会根据同步方式sleep一段时间在执行Update,高帧率可以减少消耗
            LODBias          不同LOD级别之间切换的偏移比例,设置为1在LOD边界立即切换,数值越大高模保留距离越大
            MasterTextureLimit 强制指定最高MIP等级
        加载
            AUPTimeSlice     渲染线程每帧上传数据的时间片,会消耗2倍该时间用于上传,默认值是2ms
            AUPBufferSize    主线程传递数据给渲染线程的RingBuffer大小
    5.GraphicsTier
        阴影
            CascadedShadows  级联阴影,根据摄像机观察范围划分N个等级分别使用不同的深度图,提高近处物体的精度
        HDR
            UseHDR&HDRMode   HDR模式总开关,HDR模式摄像机渲染帧缓冲的格式,FP16是64位,R11G11B10是32位不带A通道
                                开启后会额外创建一个缓冲区存储HDR计算结果
        反射
            BoxProjection    视线向量的起点不在Cubemap中心,因此需要经过计算转换为正确的采样向量
LOD
    场景 shaderLOD waterLOD grassLOD treeLOD terrainLOD thingsLOD npcLOD effectLOD lightModelLOD shadowLOD postLOD(bloom colorgrading hdr dof tod fog weather)
    角色 shaderLOD modelLOD shadowLOD animLOD visibleLOD dynamicBone lightProbes ReflectionProbes
    特效 countLOD(priority quality costlevel)
    音效 countLimit
    物理 fixedDeltaTime
    DPI  resolution
    GenerateLightmapUV
        HardAngle 三角面之间的角度大于该角度会被切割,在光照图上不连续,88度针对机械 180度针对有机体
        AngleError 提高表面的光照连续性
        AreaError
        Margin    UVChart添加间隔,避免重叠,避免双线性采样导致的错误
        ScaleInLightmap 在光照图中的缩放比例,降低像素占用
        MinLightmapResolution 默认使用LightSetting中的分辨率设置,低于该设定值时使用该分辨率
    UCChart
        MaxAngle    同HardAngle
        MaxDistance UVChart之间的距离低于指定值会被合并成一个
        IgnoreNormals 降低邻接面接缝问题(光照不连续),也可以用SeamStiching技术降低接缝问题
        MinChartSize  删除细节可忽略的三角面,降低光照图占用
画质
    低画质 DisableShadow
    中画质 ShadowMask MediumResolution HardShadowOnly StableFit
    高画质 DistanceShadowMask.40 HighResolution HardAndSoftShadow StableFit
    顶级画质 DistanceShadowMask.80 VeryHighResolution HardAndSoftShadow CloseFit FourCascades(5.7 13.3 26.7 53.3)
烘焙
    Cluster  unity先进行体素化然后对体素进行光照计算,IndirectResolution决定体素的多少,和光照图大小无关,调试阶段可以降低
    AO       调试阶段可以关闭AO生成,提高迭代速度
    LightmapParamters  提高烘焙速度Resolution-0.2 ClusterResolution0.4   Resolution-3 ClusterResolution0.6  只影响计算精度,不影响光照图大小和UV分布
    Lightmap 分辨率决定了1米多少个像素
    UVChartingControl  修改物体在光照贴图上的UV分布

    Mixed光源  根据场景原画设定灯光强度和颜色、根据原画阴影设定方向
    Baked光源  只有主光源会有很多暗角,色调单一  补光平行光光源最好一个,太多不真实,  建议用ColorGrading和Lut来处理

    球谐光照适用  结构复杂的小物件 颜色单一  UVChart分布不合理
    低画质可以降低lightprobe数量

    ReflectionProbe 256Bake 禁用Blending

    大场景拆分 避免同一物体占用不同的lightmap
灯光
    模型烘焙质量
        LightmapParamters  
    模型缩放比例
        ScaleInLightmap    粗糙非金属墙面,主要是低频光,0.5  城市街道3 野外大面积地形植被0.5 主体物件2
    光照贴图大小
        LightmapResolution 每米几个像素,数值越大质量越高内存也越大,地形0.1~0.5,室外0.5~1,室内2~3
        LightmapPadding    图元之间的像素间隔,避免不同图元由于采样算法导致混合了不同物体的光照颜色(光照溢出)
        LightmapSize       控制每张贴图最大多大,超过这个数值会生成多张
        DirectionMode      是否生成间接光的贡献度最大的光方向贴图,可以制作出间接高光效果
    光照贴图质量(样本是不是指光源发射光线的数量?)
        Bounces            光线反射次数
        EnvironmentSamples 控制环境光样本数量                                            调试阶段可以降低
        DirectSamples      控制直接光样本数量(在光源方向上采样的光线数量)                 调试阶段可以降低
        IndirectSamples    控制间接光样本数量(在半球方向上采样的光线数量,室外推荐值为100) 调试阶段可以降低
        IndirectIntensity  控制间接光整体强度
        AmbientOcclusion   控制间接光的AO效果  调试阶段可以关闭
        AlbedoBoost        控制间接光反射比例,默认值1是物理精确的
        Filter             模糊图片,减弱光照贴图噪点
    环境光照
        有三种模式,固定颜色、渐变颜色、天空盒,用来计算路径追踪没有碰到光源时的光照颜色
    环境反射
        Bounces            控制镜子类的物体互相反射最多反射几次
光照探头
    LightProbe
        数据存储
            LightmapSettings.lightProbes.bakedProbes
        自动摆放
            探针应该摆放在发生亮度变化的位置,可以沿着寻路图大量设置LightProbe,然后过滤掉变化不大的
        实时补光
            不要用补光的方式来提高角色亮度,可以在LightProbe中添加环境光来提高动态物体亮度
    ReflectionProbe
        给所有物体提供间接反射光,动态的间接高光
光照模式
    Realtime
        直接光实时计算,阴影使用ShadowMap计算(ShadowMap只计算ShadowDistance以内的动态对象)
        RealtimeGI计算静态物体表面所有可能的反射光线,运行时动态计算间接光
        IndirectMultiplier在强度不是0并且不开启RealtimeGI时会把间接光烘焙到LightMap
    Mixed
        BakeIndirect
            直接光实时计算,间接光存储在LightMap和LightProbes,阴影使用ShadowMap计算
        ShadowMask
            直接光实时计算,间接光存储在LightMap和LightProbes,阴影使用ShadowMask(最多4个Mixed光源,存储直接光被静态物体遮挡信息)
                            动态物体Receive     静态物体Receive
            动态物体Cast    ShadowMap           ShadowMap+ShadowMask
            静态物体Cast    ShadowMap           ShadowMap+ShadowMask
    Baked
        直接光、间接光、阴影烘焙到LightMap和LightProbes,只对静态物体生效,LightProbes对动态物体生效
渲染路径
    Forward
        MESH->VS->FS(光照计算)->FRAME_BUFFER
        ForwardBase: 
            #pragma multi_compile_fwdbase
            计算自发光、环境光、主平行光、SH光、光照贴图、阴影
            Unity中设置为NotImportant的光会被按照逐顶点或者SH处理
            逐顶点光照计算 Shade4PointLights(...) unity_4LightPosXYZColorAtten
            球谐光照计算 
        ForwardAdd:  
            Blend One One 
            #pragma multi_compile_fwdadd
            计算额外的逐像素光源,AddPass会根据照亮该物体的光源数量被执行多次
            照亮每个物体的逐像素光源个数有限制,Unity会根据光源的类型及对物体的影响程度(距离、强度、类型等)进行排序
            _LightColor0和_WorldSpaceLightPos0存储当前逐像素光源的颜色和位置
        光源信息
            Unity会根据当前光源类型为PASS的执行设置对应的光源属性 位置、颜色、衰减纹理、变换矩阵
            获取光的方向 
                UnityWorldSpaceLightDir(i.worldPos)
            获取光的颜色 
                _LightColor0
            获取光的衰减 
                平行光为 atten=1
                其它类型 
                        lightSpacePos=mul(_LightMatrix0,i.worldPos).xyz 
                        attenUV=dot(lightSpacePos,lightSpacePos).xx
                        atten=tex2D(_LightTexture0,attenUV).UNITY_ATTEN_CHANNEL;
                直接获取 
                        UNITY_LIGHT_ATTENUATION(atten,i,i.worldPos)
    Deferred
        第一次渲染
            不计算光照信息,只进行深度测试,光照相关数据写入G-BUFFER(坐标、法线、UV、反射系数等等)
        第二次渲染
            遍历屏幕像素,针对有效的像素点读取G-BUFFER数据进行光照计算,更新颜色缓冲区
            Unity默认使用Standard光照模型来计算,Internal-DeferrredShading.shader
        计算流程
            MESH->VS->FS(无光)->MRT(深度、法线、颜色三个BUFFER存储光照所需信息)->FRAME_BUFFER
        GBuffer信息
            RT0,存储漫反射颜色,A通道未使用
            RT1,存储高光反射颜色,A通道存储高光指数
            RT2,存储法线方向,A通道未使用
            RT3,存储自发光+光照贴图+反射探针
    ShadowCaster
        渲染阴影映射纹理时调用该shader,没有会调用Fallback的对应shader,否则不产生阴影